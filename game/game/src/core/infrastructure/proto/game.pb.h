// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_game_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_game_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_game_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_game_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_game_2eproto;
namespace proto {
class BetRecord;
struct BetRecordDefaultTypeInternal;
extern BetRecordDefaultTypeInternal _BetRecord_default_instance_;
class ConnClose;
struct ConnCloseDefaultTypeInternal;
extern ConnCloseDefaultTypeInternal _ConnClose_default_instance_;
class GameRankInfoNotify;
struct GameRankInfoNotifyDefaultTypeInternal;
extern GameRankInfoNotifyDefaultTypeInternal _GameRankInfoNotify_default_instance_;
class GameResult;
struct GameResultDefaultTypeInternal;
extern GameResultDefaultTypeInternal _GameResult_default_instance_;
class GameSnapshotNotify;
struct GameSnapshotNotifyDefaultTypeInternal;
extern GameSnapshotNotifyDefaultTypeInternal _GameSnapshotNotify_default_instance_;
class GameStopJettonNotify;
struct GameStopJettonNotifyDefaultTypeInternal;
extern GameStopJettonNotifyDefaultTypeInternal _GameStopJettonNotify_default_instance_;
class HeartBeat;
struct HeartBeatDefaultTypeInternal;
extern HeartBeatDefaultTypeInternal _HeartBeat_default_instance_;
class KickPlayerNotify;
struct KickPlayerNotifyDefaultTypeInternal;
extern KickPlayerNotifyDefaultTypeInternal _KickPlayerNotify_default_instance_;
class LoginReq;
struct LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class LoginResp;
struct LoginRespDefaultTypeInternal;
extern LoginRespDefaultTypeInternal _LoginResp_default_instance_;
class LogoutReq;
struct LogoutReqDefaultTypeInternal;
extern LogoutReqDefaultTypeInternal _LogoutReq_default_instance_;
class LogoutRes;
struct LogoutResDefaultTypeInternal;
extern LogoutResDefaultTypeInternal _LogoutRes_default_instance_;
class MinesAutoCashReq;
struct MinesAutoCashReqDefaultTypeInternal;
extern MinesAutoCashReqDefaultTypeInternal _MinesAutoCashReq_default_instance_;
class MinesAutoCashRes;
struct MinesAutoCashResDefaultTypeInternal;
extern MinesAutoCashResDefaultTypeInternal _MinesAutoCashRes_default_instance_;
class MinesCancelBetReq;
struct MinesCancelBetReqDefaultTypeInternal;
extern MinesCancelBetReqDefaultTypeInternal _MinesCancelBetReq_default_instance_;
class MinesCancelBetRes;
struct MinesCancelBetResDefaultTypeInternal;
extern MinesCancelBetResDefaultTypeInternal _MinesCancelBetRes_default_instance_;
class MinesCashReq;
struct MinesCashReqDefaultTypeInternal;
extern MinesCashReqDefaultTypeInternal _MinesCashReq_default_instance_;
class MinesCashRes;
struct MinesCashResDefaultTypeInternal;
extern MinesCashResDefaultTypeInternal _MinesCashRes_default_instance_;
class MinesPlaceBetReq;
struct MinesPlaceBetReqDefaultTypeInternal;
extern MinesPlaceBetReqDefaultTypeInternal _MinesPlaceBetReq_default_instance_;
class MinesPlaceBetRes;
struct MinesPlaceBetResDefaultTypeInternal;
extern MinesPlaceBetResDefaultTypeInternal _MinesPlaceBetRes_default_instance_;
class MinesStartJettonNotify;
struct MinesStartJettonNotifyDefaultTypeInternal;
extern MinesStartJettonNotifyDefaultTypeInternal _MinesStartJettonNotify_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PlayerInfoSnap;
struct PlayerInfoSnapDefaultTypeInternal;
extern PlayerInfoSnapDefaultTypeInternal _PlayerInfoSnap_default_instance_;
class ReckonRecord;
struct ReckonRecordDefaultTypeInternal;
extern ReckonRecordDefaultTypeInternal _ReckonRecord_default_instance_;
}  // namespace proto
PROTOBUF_NAMESPACE_OPEN
template<> ::proto::BetRecord* Arena::CreateMaybeMessage<::proto::BetRecord>(Arena*);
template<> ::proto::ConnClose* Arena::CreateMaybeMessage<::proto::ConnClose>(Arena*);
template<> ::proto::GameRankInfoNotify* Arena::CreateMaybeMessage<::proto::GameRankInfoNotify>(Arena*);
template<> ::proto::GameResult* Arena::CreateMaybeMessage<::proto::GameResult>(Arena*);
template<> ::proto::GameSnapshotNotify* Arena::CreateMaybeMessage<::proto::GameSnapshotNotify>(Arena*);
template<> ::proto::GameStopJettonNotify* Arena::CreateMaybeMessage<::proto::GameStopJettonNotify>(Arena*);
template<> ::proto::HeartBeat* Arena::CreateMaybeMessage<::proto::HeartBeat>(Arena*);
template<> ::proto::KickPlayerNotify* Arena::CreateMaybeMessage<::proto::KickPlayerNotify>(Arena*);
template<> ::proto::LoginReq* Arena::CreateMaybeMessage<::proto::LoginReq>(Arena*);
template<> ::proto::LoginResp* Arena::CreateMaybeMessage<::proto::LoginResp>(Arena*);
template<> ::proto::LogoutReq* Arena::CreateMaybeMessage<::proto::LogoutReq>(Arena*);
template<> ::proto::LogoutRes* Arena::CreateMaybeMessage<::proto::LogoutRes>(Arena*);
template<> ::proto::MinesAutoCashReq* Arena::CreateMaybeMessage<::proto::MinesAutoCashReq>(Arena*);
template<> ::proto::MinesAutoCashRes* Arena::CreateMaybeMessage<::proto::MinesAutoCashRes>(Arena*);
template<> ::proto::MinesCancelBetReq* Arena::CreateMaybeMessage<::proto::MinesCancelBetReq>(Arena*);
template<> ::proto::MinesCancelBetRes* Arena::CreateMaybeMessage<::proto::MinesCancelBetRes>(Arena*);
template<> ::proto::MinesCashReq* Arena::CreateMaybeMessage<::proto::MinesCashReq>(Arena*);
template<> ::proto::MinesCashRes* Arena::CreateMaybeMessage<::proto::MinesCashRes>(Arena*);
template<> ::proto::MinesPlaceBetReq* Arena::CreateMaybeMessage<::proto::MinesPlaceBetReq>(Arena*);
template<> ::proto::MinesPlaceBetRes* Arena::CreateMaybeMessage<::proto::MinesPlaceBetRes>(Arena*);
template<> ::proto::MinesStartJettonNotify* Arena::CreateMaybeMessage<::proto::MinesStartJettonNotify>(Arena*);
template<> ::proto::PlayerInfo* Arena::CreateMaybeMessage<::proto::PlayerInfo>(Arena*);
template<> ::proto::PlayerInfoSnap* Arena::CreateMaybeMessage<::proto::PlayerInfoSnap>(Arena*);
template<> ::proto::ReckonRecord* Arena::CreateMaybeMessage<::proto::ReckonRecord>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace proto {

// ===================================================================

class BetRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.BetRecord) */ {
 public:
  inline BetRecord() : BetRecord(nullptr) {}
  ~BetRecord() override;
  explicit PROTOBUF_CONSTEXPR BetRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BetRecord(const BetRecord& from);
  BetRecord(BetRecord&& from) noexcept
    : BetRecord() {
    *this = ::std::move(from);
  }

  inline BetRecord& operator=(const BetRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline BetRecord& operator=(BetRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BetRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const BetRecord* internal_default_instance() {
    return reinterpret_cast<const BetRecord*>(
               &_BetRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BetRecord& a, BetRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(BetRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BetRecord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BetRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BetRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BetRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BetRecord& from) {
    BetRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BetRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.BetRecord";
  }
  protected:
  explicit BetRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 2,
    kPlayTypeFieldNumber = 1,
  };
  // double amount = 2;
  void clear_amount();
  double amount() const;
  void set_amount(double value);
  private:
  double _internal_amount() const;
  void _internal_set_amount(double value);
  public:

  // int32 playType = 1;
  void clear_playtype();
  int32_t playtype() const;
  void set_playtype(int32_t value);
  private:
  int32_t _internal_playtype() const;
  void _internal_set_playtype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.BetRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double amount_;
    int32_t playtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class ReckonRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.ReckonRecord) */ {
 public:
  inline ReckonRecord() : ReckonRecord(nullptr) {}
  ~ReckonRecord() override;
  explicit PROTOBUF_CONSTEXPR ReckonRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReckonRecord(const ReckonRecord& from);
  ReckonRecord(ReckonRecord&& from) noexcept
    : ReckonRecord() {
    *this = ::std::move(from);
  }

  inline ReckonRecord& operator=(const ReckonRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReckonRecord& operator=(ReckonRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReckonRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReckonRecord* internal_default_instance() {
    return reinterpret_cast<const ReckonRecord*>(
               &_ReckonRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ReckonRecord& a, ReckonRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(ReckonRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReckonRecord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReckonRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReckonRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReckonRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReckonRecord& from) {
    ReckonRecord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReckonRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ReckonRecord";
  }
  protected:
  explicit ReckonRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmountFieldNumber = 2,
    kMultiFieldNumber = 3,
    kPlayTypeFieldNumber = 1,
  };
  // double amount = 2;
  void clear_amount();
  double amount() const;
  void set_amount(double value);
  private:
  double _internal_amount() const;
  void _internal_set_amount(double value);
  public:

  // double multi = 3;
  void clear_multi();
  double multi() const;
  void set_multi(double value);
  private:
  double _internal_multi() const;
  void _internal_set_multi(double value);
  public:

  // int32 playType = 1;
  void clear_playtype();
  int32_t playtype() const;
  void set_playtype(int32_t value);
  private:
  int32_t _internal_playtype() const;
  void _internal_set_playtype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.ReckonRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double amount_;
    double multi_;
    int32_t playtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  explicit PROTOBUF_CONSTEXPR PlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerInfo& from) {
    PlayerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kNicknameFieldNumber = 2,
    kAvatarFieldNumber = 3,
    kCurrencyFieldNumber = 6,
    kLoginnameFieldNumber = 7,
    kBalanceFieldNumber = 5,
    kVipFieldNumber = 4,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string nickname = 2;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // string avatar = 3;
  void clear_avatar();
  const std::string& avatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar();
  PROTOBUF_NODISCARD std::string* release_avatar();
  void set_allocated_avatar(std::string* avatar);
  private:
  const std::string& _internal_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar(const std::string& value);
  std::string* _internal_mutable_avatar();
  public:

  // string currency = 6;
  void clear_currency();
  const std::string& currency() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currency(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currency();
  PROTOBUF_NODISCARD std::string* release_currency();
  void set_allocated_currency(std::string* currency);
  private:
  const std::string& _internal_currency() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currency(const std::string& value);
  std::string* _internal_mutable_currency();
  public:

  // string loginname = 7;
  void clear_loginname();
  const std::string& loginname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loginname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loginname();
  PROTOBUF_NODISCARD std::string* release_loginname();
  void set_allocated_loginname(std::string* loginname);
  private:
  const std::string& _internal_loginname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loginname(const std::string& value);
  std::string* _internal_mutable_loginname();
  public:

  // double balance = 5;
  void clear_balance();
  double balance() const;
  void set_balance(double value);
  private:
  double _internal_balance() const;
  void _internal_set_balance(double value);
  public:

  // int32 vip = 4;
  void clear_vip();
  int32_t vip() const;
  void set_vip(int32_t value);
  private:
  int32_t _internal_vip() const;
  void _internal_set_vip(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currency_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loginname_;
    double balance_;
    int32_t vip_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfoSnap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.PlayerInfoSnap) */ {
 public:
  inline PlayerInfoSnap() : PlayerInfoSnap(nullptr) {}
  ~PlayerInfoSnap() override;
  explicit PROTOBUF_CONSTEXPR PlayerInfoSnap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfoSnap(const PlayerInfoSnap& from);
  PlayerInfoSnap(PlayerInfoSnap&& from) noexcept
    : PlayerInfoSnap() {
    *this = ::std::move(from);
  }

  inline PlayerInfoSnap& operator=(const PlayerInfoSnap& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfoSnap& operator=(PlayerInfoSnap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfoSnap& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfoSnap* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoSnap*>(
               &_PlayerInfoSnap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PlayerInfoSnap& a, PlayerInfoSnap& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfoSnap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfoSnap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfoSnap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfoSnap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerInfoSnap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerInfoSnap& from) {
    PlayerInfoSnap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfoSnap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.PlayerInfoSnap";
  }
  protected:
  explicit PlayerInfoSnap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBetsFieldNumber = 2,
    kReckonsFieldNumber = 3,
    kInfoFieldNumber = 1,
  };
  // repeated .proto.BetRecord bets = 2;
  int bets_size() const;
  private:
  int _internal_bets_size() const;
  public:
  void clear_bets();
  ::proto::BetRecord* mutable_bets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::BetRecord >*
      mutable_bets();
  private:
  const ::proto::BetRecord& _internal_bets(int index) const;
  ::proto::BetRecord* _internal_add_bets();
  public:
  const ::proto::BetRecord& bets(int index) const;
  ::proto::BetRecord* add_bets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::BetRecord >&
      bets() const;

  // repeated .proto.ReckonRecord reckons = 3;
  int reckons_size() const;
  private:
  int _internal_reckons_size() const;
  public:
  void clear_reckons();
  ::proto::ReckonRecord* mutable_reckons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ReckonRecord >*
      mutable_reckons();
  private:
  const ::proto::ReckonRecord& _internal_reckons(int index) const;
  ::proto::ReckonRecord* _internal_add_reckons();
  public:
  const ::proto::ReckonRecord& reckons(int index) const;
  ::proto::ReckonRecord* add_reckons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ReckonRecord >&
      reckons() const;

  // .proto.PlayerInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::proto::PlayerInfo& info() const;
  PROTOBUF_NODISCARD ::proto::PlayerInfo* release_info();
  ::proto::PlayerInfo* mutable_info();
  void set_allocated_info(::proto::PlayerInfo* info);
  private:
  const ::proto::PlayerInfo& _internal_info() const;
  ::proto::PlayerInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::proto::PlayerInfo* info);
  ::proto::PlayerInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:proto.PlayerInfoSnap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::BetRecord > bets_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ReckonRecord > reckons_;
    ::proto::PlayerInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GameResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.GameResult) */ {
 public:
  inline GameResult() : GameResult(nullptr) {}
  ~GameResult() override;
  explicit PROTOBUF_CONSTEXPR GameResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameResult(const GameResult& from);
  GameResult(GameResult&& from) noexcept
    : GameResult() {
    *this = ::std::move(from);
  }

  inline GameResult& operator=(const GameResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameResult& operator=(GameResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameResult* internal_default_instance() {
    return reinterpret_cast<const GameResult*>(
               &_GameResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GameResult& a, GameResult& b) {
    a.Swap(&b);
  }
  inline void Swap(GameResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameResult& from) {
    GameResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.GameResult";
  }
  protected:
  explicit GameResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMultiFieldNumber = 2,
    kResultFieldNumber = 1,
    kIndexFieldNumber = 3,
  };
  // double multi = 2;
  void clear_multi();
  double multi() const;
  void set_multi(double value);
  private:
  double _internal_multi() const;
  void _internal_set_multi(double value);
  public:

  // int32 result = 1;
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // int32 index = 3;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.GameResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double multi_;
    int32_t result_;
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class HeartBeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.HeartBeat) */ {
 public:
  inline HeartBeat() : HeartBeat(nullptr) {}
  ~HeartBeat() override;
  explicit PROTOBUF_CONSTEXPR HeartBeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartBeat(const HeartBeat& from);
  HeartBeat(HeartBeat&& from) noexcept
    : HeartBeat() {
    *this = ::std::move(from);
  }

  inline HeartBeat& operator=(const HeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartBeat& operator=(HeartBeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartBeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartBeat* internal_default_instance() {
    return reinterpret_cast<const HeartBeat*>(
               &_HeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HeartBeat& a, HeartBeat& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartBeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartBeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartBeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartBeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartBeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartBeat& from) {
    HeartBeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartBeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.HeartBeat";
  }
  protected:
  explicit HeartBeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.HeartBeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.LoginReq) */ {
 public:
  inline LoginReq() : LoginReq(nullptr) {}
  ~LoginReq() override;
  explicit PROTOBUF_CONSTEXPR LoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReq(const LoginReq& from);
  LoginReq(LoginReq&& from) noexcept
    : LoginReq() {
    *this = ::std::move(from);
  }

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReq& operator=(LoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoginReq& a, LoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginReq& from) {
    LoginReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.LoginReq";
  }
  protected:
  explicit LoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginnameFieldNumber = 1,
    kTokenFieldNumber = 2,
    kGameTypeFieldNumber = 3,
    kClientIpFieldNumber = 5,
    kVersionFieldNumber = 4,
  };
  // string loginname = 1;
  void clear_loginname();
  const std::string& loginname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loginname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loginname();
  PROTOBUF_NODISCARD std::string* release_loginname();
  void set_allocated_loginname(std::string* loginname);
  private:
  const std::string& _internal_loginname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loginname(const std::string& value);
  std::string* _internal_mutable_loginname();
  public:

  // string token = 2;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string game_type = 3;
  void clear_game_type();
  const std::string& game_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_type();
  PROTOBUF_NODISCARD std::string* release_game_type();
  void set_allocated_game_type(std::string* game_type);
  private:
  const std::string& _internal_game_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_type(const std::string& value);
  std::string* _internal_mutable_game_type();
  public:

  // string client_ip = 5;
  void clear_client_ip();
  const std::string& client_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_ip();
  PROTOBUF_NODISCARD std::string* release_client_ip();
  void set_allocated_client_ip(std::string* client_ip);
  private:
  const std::string& _internal_client_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_ip(const std::string& value);
  std::string* _internal_mutable_client_ip();
  public:

  // uint32 version = 4;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.LoginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loginname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_ip_;
    uint32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LoginResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.LoginResp) */ {
 public:
  inline LoginResp() : LoginResp(nullptr) {}
  ~LoginResp() override;
  explicit PROTOBUF_CONSTEXPR LoginResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResp(const LoginResp& from);
  LoginResp(LoginResp&& from) noexcept
    : LoginResp() {
    *this = ::std::move(from);
  }

  inline LoginResp& operator=(const LoginResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResp& operator=(LoginResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResp* internal_default_instance() {
    return reinterpret_cast<const LoginResp*>(
               &_LoginResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LoginResp& a, LoginResp& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResp& from) {
    LoginResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.LoginResp";
  }
  protected:
  explicit LoginResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginnameFieldNumber = 1,
    kMessageFieldNumber = 3,
    kInfoFieldNumber = 4,
    kCodeFieldNumber = 2,
  };
  // string loginname = 1;
  void clear_loginname();
  const std::string& loginname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loginname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loginname();
  PROTOBUF_NODISCARD std::string* release_loginname();
  void set_allocated_loginname(std::string* loginname);
  private:
  const std::string& _internal_loginname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loginname(const std::string& value);
  std::string* _internal_mutable_loginname();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .proto.PlayerInfo info = 4;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::proto::PlayerInfo& info() const;
  PROTOBUF_NODISCARD ::proto::PlayerInfo* release_info();
  ::proto::PlayerInfo* mutable_info();
  void set_allocated_info(::proto::PlayerInfo* info);
  private:
  const ::proto::PlayerInfo& _internal_info() const;
  ::proto::PlayerInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::proto::PlayerInfo* info);
  ::proto::PlayerInfo* unsafe_arena_release_info();

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.LoginResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loginname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::proto::PlayerInfo* info_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LogoutReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.LogoutReq) */ {
 public:
  inline LogoutReq() : LogoutReq(nullptr) {}
  ~LogoutReq() override;
  explicit PROTOBUF_CONSTEXPR LogoutReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutReq(const LogoutReq& from);
  LogoutReq(LogoutReq&& from) noexcept
    : LogoutReq() {
    *this = ::std::move(from);
  }

  inline LogoutReq& operator=(const LogoutReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutReq& operator=(LogoutReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutReq* internal_default_instance() {
    return reinterpret_cast<const LogoutReq*>(
               &_LogoutReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LogoutReq& a, LogoutReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutReq& from) {
    LogoutReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.LogoutReq";
  }
  protected:
  explicit LogoutReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginnameFieldNumber = 1,
  };
  // string loginname = 1;
  void clear_loginname();
  const std::string& loginname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loginname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loginname();
  PROTOBUF_NODISCARD std::string* release_loginname();
  void set_allocated_loginname(std::string* loginname);
  private:
  const std::string& _internal_loginname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loginname(const std::string& value);
  std::string* _internal_mutable_loginname();
  public:

  // @@protoc_insertion_point(class_scope:proto.LogoutReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loginname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class LogoutRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.LogoutRes) */ {
 public:
  inline LogoutRes() : LogoutRes(nullptr) {}
  ~LogoutRes() override;
  explicit PROTOBUF_CONSTEXPR LogoutRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutRes(const LogoutRes& from);
  LogoutRes(LogoutRes&& from) noexcept
    : LogoutRes() {
    *this = ::std::move(from);
  }

  inline LogoutRes& operator=(const LogoutRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutRes& operator=(LogoutRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutRes* internal_default_instance() {
    return reinterpret_cast<const LogoutRes*>(
               &_LogoutRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LogoutRes& a, LogoutRes& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutRes& from) {
    LogoutRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.LogoutRes";
  }
  protected:
  explicit LogoutRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginnameFieldNumber = 1,
    kMsgFieldNumber = 3,
    kCodeFieldNumber = 2,
  };
  // string loginname = 1;
  void clear_loginname();
  const std::string& loginname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loginname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loginname();
  PROTOBUF_NODISCARD std::string* release_loginname();
  void set_allocated_loginname(std::string* loginname);
  private:
  const std::string& _internal_loginname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loginname(const std::string& value);
  std::string* _internal_mutable_loginname();
  public:

  // string msg = 3;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.LogoutRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loginname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class KickPlayerNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.KickPlayerNotify) */ {
 public:
  inline KickPlayerNotify() : KickPlayerNotify(nullptr) {}
  ~KickPlayerNotify() override;
  explicit PROTOBUF_CONSTEXPR KickPlayerNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KickPlayerNotify(const KickPlayerNotify& from);
  KickPlayerNotify(KickPlayerNotify&& from) noexcept
    : KickPlayerNotify() {
    *this = ::std::move(from);
  }

  inline KickPlayerNotify& operator=(const KickPlayerNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline KickPlayerNotify& operator=(KickPlayerNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KickPlayerNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const KickPlayerNotify* internal_default_instance() {
    return reinterpret_cast<const KickPlayerNotify*>(
               &_KickPlayerNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(KickPlayerNotify& a, KickPlayerNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(KickPlayerNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KickPlayerNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KickPlayerNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KickPlayerNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KickPlayerNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KickPlayerNotify& from) {
    KickPlayerNotify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KickPlayerNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.KickPlayerNotify";
  }
  protected:
  explicit KickPlayerNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  // string sessionId = 1;
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // int32 reason = 2;
  void clear_reason();
  int32_t reason() const;
  void set_reason(int32_t value);
  private:
  int32_t _internal_reason() const;
  void _internal_set_reason(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.KickPlayerNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
    int32_t reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GameSnapshotNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.GameSnapshotNotify) */ {
 public:
  inline GameSnapshotNotify() : GameSnapshotNotify(nullptr) {}
  ~GameSnapshotNotify() override;
  explicit PROTOBUF_CONSTEXPR GameSnapshotNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameSnapshotNotify(const GameSnapshotNotify& from);
  GameSnapshotNotify(GameSnapshotNotify&& from) noexcept
    : GameSnapshotNotify() {
    *this = ::std::move(from);
  }

  inline GameSnapshotNotify& operator=(const GameSnapshotNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameSnapshotNotify& operator=(GameSnapshotNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameSnapshotNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameSnapshotNotify* internal_default_instance() {
    return reinterpret_cast<const GameSnapshotNotify*>(
               &_GameSnapshotNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GameSnapshotNotify& a, GameSnapshotNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(GameSnapshotNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameSnapshotNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameSnapshotNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameSnapshotNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameSnapshotNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameSnapshotNotify& from) {
    GameSnapshotNotify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameSnapshotNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.GameSnapshotNotify";
  }
  protected:
  explicit GameSnapshotNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 7,
    kRoundIdFieldNumber = 1,
    kGameTypeFieldNumber = 2,
    kRemainTimeFieldNumber = 4,
    kStatusFieldNumber = 3,
    kCurIndexFieldNumber = 5,
    kCurMultiFieldNumber = 6,
  };
  // repeated .proto.GameResult result = 7;
  int result_size() const;
  private:
  int _internal_result_size() const;
  public:
  void clear_result();
  ::proto::GameResult* mutable_result(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::GameResult >*
      mutable_result();
  private:
  const ::proto::GameResult& _internal_result(int index) const;
  ::proto::GameResult* _internal_add_result();
  public:
  const ::proto::GameResult& result(int index) const;
  ::proto::GameResult* add_result();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::GameResult >&
      result() const;

  // string roundId = 1;
  void clear_roundid();
  const std::string& roundid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roundid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roundid();
  PROTOBUF_NODISCARD std::string* release_roundid();
  void set_allocated_roundid(std::string* roundid);
  private:
  const std::string& _internal_roundid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roundid(const std::string& value);
  std::string* _internal_mutable_roundid();
  public:

  // string gameType = 2;
  void clear_gametype();
  const std::string& gametype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gametype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gametype();
  PROTOBUF_NODISCARD std::string* release_gametype();
  void set_allocated_gametype(std::string* gametype);
  private:
  const std::string& _internal_gametype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gametype(const std::string& value);
  std::string* _internal_mutable_gametype();
  public:

  // int64 remainTime = 4;
  void clear_remaintime();
  int64_t remaintime() const;
  void set_remaintime(int64_t value);
  private:
  int64_t _internal_remaintime() const;
  void _internal_set_remaintime(int64_t value);
  public:

  // int32 status = 3;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // int32 curIndex = 5;
  void clear_curindex();
  int32_t curindex() const;
  void set_curindex(int32_t value);
  private:
  int32_t _internal_curindex() const;
  void _internal_set_curindex(int32_t value);
  public:

  // double curMulti = 6;
  void clear_curmulti();
  double curmulti() const;
  void set_curmulti(double value);
  private:
  double _internal_curmulti() const;
  void _internal_set_curmulti(double value);
  public:

  // @@protoc_insertion_point(class_scope:proto.GameSnapshotNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::GameResult > result_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roundid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gametype_;
    int64_t remaintime_;
    int32_t status_;
    int32_t curindex_;
    double curmulti_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MinesPlaceBetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.MinesPlaceBetReq) */ {
 public:
  inline MinesPlaceBetReq() : MinesPlaceBetReq(nullptr) {}
  ~MinesPlaceBetReq() override;
  explicit PROTOBUF_CONSTEXPR MinesPlaceBetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MinesPlaceBetReq(const MinesPlaceBetReq& from);
  MinesPlaceBetReq(MinesPlaceBetReq&& from) noexcept
    : MinesPlaceBetReq() {
    *this = ::std::move(from);
  }

  inline MinesPlaceBetReq& operator=(const MinesPlaceBetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MinesPlaceBetReq& operator=(MinesPlaceBetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MinesPlaceBetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MinesPlaceBetReq* internal_default_instance() {
    return reinterpret_cast<const MinesPlaceBetReq*>(
               &_MinesPlaceBetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MinesPlaceBetReq& a, MinesPlaceBetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MinesPlaceBetReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MinesPlaceBetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MinesPlaceBetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MinesPlaceBetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MinesPlaceBetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MinesPlaceBetReq& from) {
    MinesPlaceBetReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MinesPlaceBetReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.MinesPlaceBetReq";
  }
  protected:
  explicit MinesPlaceBetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginnameFieldNumber = 1,
    kRoundIdFieldNumber = 2,
    kAmountFieldNumber = 4,
    kPlayTypeFieldNumber = 3,
  };
  // string loginname = 1;
  void clear_loginname();
  const std::string& loginname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loginname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loginname();
  PROTOBUF_NODISCARD std::string* release_loginname();
  void set_allocated_loginname(std::string* loginname);
  private:
  const std::string& _internal_loginname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loginname(const std::string& value);
  std::string* _internal_mutable_loginname();
  public:

  // string roundId = 2;
  void clear_roundid();
  const std::string& roundid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roundid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roundid();
  PROTOBUF_NODISCARD std::string* release_roundid();
  void set_allocated_roundid(std::string* roundid);
  private:
  const std::string& _internal_roundid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roundid(const std::string& value);
  std::string* _internal_mutable_roundid();
  public:

  // double amount = 4;
  void clear_amount();
  double amount() const;
  void set_amount(double value);
  private:
  double _internal_amount() const;
  void _internal_set_amount(double value);
  public:

  // int32 playType = 3;
  void clear_playtype();
  int32_t playtype() const;
  void set_playtype(int32_t value);
  private:
  int32_t _internal_playtype() const;
  void _internal_set_playtype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.MinesPlaceBetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loginname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roundid_;
    double amount_;
    int32_t playtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MinesPlaceBetRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.MinesPlaceBetRes) */ {
 public:
  inline MinesPlaceBetRes() : MinesPlaceBetRes(nullptr) {}
  ~MinesPlaceBetRes() override;
  explicit PROTOBUF_CONSTEXPR MinesPlaceBetRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MinesPlaceBetRes(const MinesPlaceBetRes& from);
  MinesPlaceBetRes(MinesPlaceBetRes&& from) noexcept
    : MinesPlaceBetRes() {
    *this = ::std::move(from);
  }

  inline MinesPlaceBetRes& operator=(const MinesPlaceBetRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MinesPlaceBetRes& operator=(MinesPlaceBetRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MinesPlaceBetRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MinesPlaceBetRes* internal_default_instance() {
    return reinterpret_cast<const MinesPlaceBetRes*>(
               &_MinesPlaceBetRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MinesPlaceBetRes& a, MinesPlaceBetRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MinesPlaceBetRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MinesPlaceBetRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MinesPlaceBetRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MinesPlaceBetRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MinesPlaceBetRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MinesPlaceBetRes& from) {
    MinesPlaceBetRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MinesPlaceBetRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.MinesPlaceBetRes";
  }
  protected:
  explicit MinesPlaceBetRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kRoundIdFieldNumber = 3,
    kBetFieldNumber = 4,
    kBalanceFieldNumber = 5,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string roundId = 3;
  void clear_roundid();
  const std::string& roundid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roundid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roundid();
  PROTOBUF_NODISCARD std::string* release_roundid();
  void set_allocated_roundid(std::string* roundid);
  private:
  const std::string& _internal_roundid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roundid(const std::string& value);
  std::string* _internal_mutable_roundid();
  public:

  // .proto.BetRecord bet = 4;
  bool has_bet() const;
  private:
  bool _internal_has_bet() const;
  public:
  void clear_bet();
  const ::proto::BetRecord& bet() const;
  PROTOBUF_NODISCARD ::proto::BetRecord* release_bet();
  ::proto::BetRecord* mutable_bet();
  void set_allocated_bet(::proto::BetRecord* bet);
  private:
  const ::proto::BetRecord& _internal_bet() const;
  ::proto::BetRecord* _internal_mutable_bet();
  public:
  void unsafe_arena_set_allocated_bet(
      ::proto::BetRecord* bet);
  ::proto::BetRecord* unsafe_arena_release_bet();

  // double balance = 5;
  void clear_balance();
  double balance() const;
  void set_balance(double value);
  private:
  double _internal_balance() const;
  void _internal_set_balance(double value);
  public:

  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.MinesPlaceBetRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roundid_;
    ::proto::BetRecord* bet_;
    double balance_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MinesAutoCashReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.MinesAutoCashReq) */ {
 public:
  inline MinesAutoCashReq() : MinesAutoCashReq(nullptr) {}
  ~MinesAutoCashReq() override;
  explicit PROTOBUF_CONSTEXPR MinesAutoCashReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MinesAutoCashReq(const MinesAutoCashReq& from);
  MinesAutoCashReq(MinesAutoCashReq&& from) noexcept
    : MinesAutoCashReq() {
    *this = ::std::move(from);
  }

  inline MinesAutoCashReq& operator=(const MinesAutoCashReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MinesAutoCashReq& operator=(MinesAutoCashReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MinesAutoCashReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MinesAutoCashReq* internal_default_instance() {
    return reinterpret_cast<const MinesAutoCashReq*>(
               &_MinesAutoCashReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MinesAutoCashReq& a, MinesAutoCashReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MinesAutoCashReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MinesAutoCashReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MinesAutoCashReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MinesAutoCashReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MinesAutoCashReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MinesAutoCashReq& from) {
    MinesAutoCashReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MinesAutoCashReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.MinesAutoCashReq";
  }
  protected:
  explicit MinesAutoCashReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginnameFieldNumber = 1,
    kRoundIdFieldNumber = 2,
    kPlayTypeFieldNumber = 3,
    kEnableFieldNumber = 4,
    kGridFieldNumber = 5,
  };
  // string loginname = 1;
  void clear_loginname();
  const std::string& loginname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loginname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loginname();
  PROTOBUF_NODISCARD std::string* release_loginname();
  void set_allocated_loginname(std::string* loginname);
  private:
  const std::string& _internal_loginname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loginname(const std::string& value);
  std::string* _internal_mutable_loginname();
  public:

  // string roundId = 2;
  void clear_roundid();
  const std::string& roundid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roundid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roundid();
  PROTOBUF_NODISCARD std::string* release_roundid();
  void set_allocated_roundid(std::string* roundid);
  private:
  const std::string& _internal_roundid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roundid(const std::string& value);
  std::string* _internal_mutable_roundid();
  public:

  // int32 playType = 3;
  void clear_playtype();
  int32_t playtype() const;
  void set_playtype(int32_t value);
  private:
  int32_t _internal_playtype() const;
  void _internal_set_playtype(int32_t value);
  public:

  // int32 enable = 4;
  void clear_enable();
  int32_t enable() const;
  void set_enable(int32_t value);
  private:
  int32_t _internal_enable() const;
  void _internal_set_enable(int32_t value);
  public:

  // int32 grid = 5;
  void clear_grid();
  int32_t grid() const;
  void set_grid(int32_t value);
  private:
  int32_t _internal_grid() const;
  void _internal_set_grid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.MinesAutoCashReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loginname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roundid_;
    int32_t playtype_;
    int32_t enable_;
    int32_t grid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MinesAutoCashRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.MinesAutoCashRes) */ {
 public:
  inline MinesAutoCashRes() : MinesAutoCashRes(nullptr) {}
  ~MinesAutoCashRes() override;
  explicit PROTOBUF_CONSTEXPR MinesAutoCashRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MinesAutoCashRes(const MinesAutoCashRes& from);
  MinesAutoCashRes(MinesAutoCashRes&& from) noexcept
    : MinesAutoCashRes() {
    *this = ::std::move(from);
  }

  inline MinesAutoCashRes& operator=(const MinesAutoCashRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MinesAutoCashRes& operator=(MinesAutoCashRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MinesAutoCashRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MinesAutoCashRes* internal_default_instance() {
    return reinterpret_cast<const MinesAutoCashRes*>(
               &_MinesAutoCashRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MinesAutoCashRes& a, MinesAutoCashRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MinesAutoCashRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MinesAutoCashRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MinesAutoCashRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MinesAutoCashRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MinesAutoCashRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MinesAutoCashRes& from) {
    MinesAutoCashRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MinesAutoCashRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.MinesAutoCashRes";
  }
  protected:
  explicit MinesAutoCashRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoundIdFieldNumber = 1,
    kMessageFieldNumber = 3,
    kCodeFieldNumber = 2,
    kEnableFieldNumber = 4,
    kGridFieldNumber = 5,
    kPlayTypeFieldNumber = 6,
  };
  // string roundId = 1;
  void clear_roundid();
  const std::string& roundid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roundid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roundid();
  PROTOBUF_NODISCARD std::string* release_roundid();
  void set_allocated_roundid(std::string* roundid);
  private:
  const std::string& _internal_roundid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roundid(const std::string& value);
  std::string* _internal_mutable_roundid();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // int32 enable = 4;
  void clear_enable();
  int32_t enable() const;
  void set_enable(int32_t value);
  private:
  int32_t _internal_enable() const;
  void _internal_set_enable(int32_t value);
  public:

  // int32 grid = 5;
  void clear_grid();
  int32_t grid() const;
  void set_grid(int32_t value);
  private:
  int32_t _internal_grid() const;
  void _internal_set_grid(int32_t value);
  public:

  // int32 playType = 6;
  void clear_playtype();
  int32_t playtype() const;
  void set_playtype(int32_t value);
  private:
  int32_t _internal_playtype() const;
  void _internal_set_playtype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.MinesAutoCashRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roundid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t code_;
    int32_t enable_;
    int32_t grid_;
    int32_t playtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MinesCashReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.MinesCashReq) */ {
 public:
  inline MinesCashReq() : MinesCashReq(nullptr) {}
  ~MinesCashReq() override;
  explicit PROTOBUF_CONSTEXPR MinesCashReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MinesCashReq(const MinesCashReq& from);
  MinesCashReq(MinesCashReq&& from) noexcept
    : MinesCashReq() {
    *this = ::std::move(from);
  }

  inline MinesCashReq& operator=(const MinesCashReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MinesCashReq& operator=(MinesCashReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MinesCashReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MinesCashReq* internal_default_instance() {
    return reinterpret_cast<const MinesCashReq*>(
               &_MinesCashReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MinesCashReq& a, MinesCashReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MinesCashReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MinesCashReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MinesCashReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MinesCashReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MinesCashReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MinesCashReq& from) {
    MinesCashReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MinesCashReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.MinesCashReq";
  }
  protected:
  explicit MinesCashReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginnameFieldNumber = 1,
    kRoundIdFieldNumber = 2,
    kPlayTypeFieldNumber = 3,
  };
  // string loginname = 1;
  void clear_loginname();
  const std::string& loginname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loginname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loginname();
  PROTOBUF_NODISCARD std::string* release_loginname();
  void set_allocated_loginname(std::string* loginname);
  private:
  const std::string& _internal_loginname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loginname(const std::string& value);
  std::string* _internal_mutable_loginname();
  public:

  // string roundId = 2;
  void clear_roundid();
  const std::string& roundid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roundid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roundid();
  PROTOBUF_NODISCARD std::string* release_roundid();
  void set_allocated_roundid(std::string* roundid);
  private:
  const std::string& _internal_roundid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roundid(const std::string& value);
  std::string* _internal_mutable_roundid();
  public:

  // int32 playType = 3;
  void clear_playtype();
  int32_t playtype() const;
  void set_playtype(int32_t value);
  private:
  int32_t _internal_playtype() const;
  void _internal_set_playtype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.MinesCashReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loginname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roundid_;
    int32_t playtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MinesCashRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.MinesCashRes) */ {
 public:
  inline MinesCashRes() : MinesCashRes(nullptr) {}
  ~MinesCashRes() override;
  explicit PROTOBUF_CONSTEXPR MinesCashRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MinesCashRes(const MinesCashRes& from);
  MinesCashRes(MinesCashRes&& from) noexcept
    : MinesCashRes() {
    *this = ::std::move(from);
  }

  inline MinesCashRes& operator=(const MinesCashRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MinesCashRes& operator=(MinesCashRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MinesCashRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MinesCashRes* internal_default_instance() {
    return reinterpret_cast<const MinesCashRes*>(
               &_MinesCashRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MinesCashRes& a, MinesCashRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MinesCashRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MinesCashRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MinesCashRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MinesCashRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MinesCashRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MinesCashRes& from) {
    MinesCashRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MinesCashRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.MinesCashRes";
  }
  protected:
  explicit MinesCashRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoundIdFieldNumber = 1,
    kMessageFieldNumber = 3,
    kReckonFieldNumber = 4,
    kCodeFieldNumber = 2,
    kPlayTypeFieldNumber = 6,
    kBalanceFieldNumber = 5,
  };
  // string roundId = 1;
  void clear_roundid();
  const std::string& roundid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roundid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roundid();
  PROTOBUF_NODISCARD std::string* release_roundid();
  void set_allocated_roundid(std::string* roundid);
  private:
  const std::string& _internal_roundid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roundid(const std::string& value);
  std::string* _internal_mutable_roundid();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .proto.ReckonRecord reckon = 4;
  bool has_reckon() const;
  private:
  bool _internal_has_reckon() const;
  public:
  void clear_reckon();
  const ::proto::ReckonRecord& reckon() const;
  PROTOBUF_NODISCARD ::proto::ReckonRecord* release_reckon();
  ::proto::ReckonRecord* mutable_reckon();
  void set_allocated_reckon(::proto::ReckonRecord* reckon);
  private:
  const ::proto::ReckonRecord& _internal_reckon() const;
  ::proto::ReckonRecord* _internal_mutable_reckon();
  public:
  void unsafe_arena_set_allocated_reckon(
      ::proto::ReckonRecord* reckon);
  ::proto::ReckonRecord* unsafe_arena_release_reckon();

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // int32 playType = 6;
  void clear_playtype();
  int32_t playtype() const;
  void set_playtype(int32_t value);
  private:
  int32_t _internal_playtype() const;
  void _internal_set_playtype(int32_t value);
  public:

  // double balance = 5;
  void clear_balance();
  double balance() const;
  void set_balance(double value);
  private:
  double _internal_balance() const;
  void _internal_set_balance(double value);
  public:

  // @@protoc_insertion_point(class_scope:proto.MinesCashRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roundid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::proto::ReckonRecord* reckon_;
    int32_t code_;
    int32_t playtype_;
    double balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MinesCancelBetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.MinesCancelBetReq) */ {
 public:
  inline MinesCancelBetReq() : MinesCancelBetReq(nullptr) {}
  ~MinesCancelBetReq() override;
  explicit PROTOBUF_CONSTEXPR MinesCancelBetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MinesCancelBetReq(const MinesCancelBetReq& from);
  MinesCancelBetReq(MinesCancelBetReq&& from) noexcept
    : MinesCancelBetReq() {
    *this = ::std::move(from);
  }

  inline MinesCancelBetReq& operator=(const MinesCancelBetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MinesCancelBetReq& operator=(MinesCancelBetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MinesCancelBetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MinesCancelBetReq* internal_default_instance() {
    return reinterpret_cast<const MinesCancelBetReq*>(
               &_MinesCancelBetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(MinesCancelBetReq& a, MinesCancelBetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MinesCancelBetReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MinesCancelBetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MinesCancelBetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MinesCancelBetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MinesCancelBetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MinesCancelBetReq& from) {
    MinesCancelBetReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MinesCancelBetReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.MinesCancelBetReq";
  }
  protected:
  explicit MinesCancelBetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginnameFieldNumber = 1,
    kRoundIdFieldNumber = 2,
    kPlayTypeFieldNumber = 3,
  };
  // string loginname = 1;
  void clear_loginname();
  const std::string& loginname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loginname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loginname();
  PROTOBUF_NODISCARD std::string* release_loginname();
  void set_allocated_loginname(std::string* loginname);
  private:
  const std::string& _internal_loginname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loginname(const std::string& value);
  std::string* _internal_mutable_loginname();
  public:

  // string roundId = 2;
  void clear_roundid();
  const std::string& roundid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roundid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roundid();
  PROTOBUF_NODISCARD std::string* release_roundid();
  void set_allocated_roundid(std::string* roundid);
  private:
  const std::string& _internal_roundid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roundid(const std::string& value);
  std::string* _internal_mutable_roundid();
  public:

  // int32 playType = 3;
  void clear_playtype();
  int32_t playtype() const;
  void set_playtype(int32_t value);
  private:
  int32_t _internal_playtype() const;
  void _internal_set_playtype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.MinesCancelBetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loginname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roundid_;
    int32_t playtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MinesCancelBetRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.MinesCancelBetRes) */ {
 public:
  inline MinesCancelBetRes() : MinesCancelBetRes(nullptr) {}
  ~MinesCancelBetRes() override;
  explicit PROTOBUF_CONSTEXPR MinesCancelBetRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MinesCancelBetRes(const MinesCancelBetRes& from);
  MinesCancelBetRes(MinesCancelBetRes&& from) noexcept
    : MinesCancelBetRes() {
    *this = ::std::move(from);
  }

  inline MinesCancelBetRes& operator=(const MinesCancelBetRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MinesCancelBetRes& operator=(MinesCancelBetRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MinesCancelBetRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MinesCancelBetRes* internal_default_instance() {
    return reinterpret_cast<const MinesCancelBetRes*>(
               &_MinesCancelBetRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(MinesCancelBetRes& a, MinesCancelBetRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MinesCancelBetRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MinesCancelBetRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MinesCancelBetRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MinesCancelBetRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MinesCancelBetRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MinesCancelBetRes& from) {
    MinesCancelBetRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MinesCancelBetRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.MinesCancelBetRes";
  }
  protected:
  explicit MinesCancelBetRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoundIdFieldNumber = 1,
    kMessageFieldNumber = 3,
    kRefundAmountFieldNumber = 4,
    kCodeFieldNumber = 2,
    kPlayTypeFieldNumber = 6,
    kBalanceFieldNumber = 5,
  };
  // string roundId = 1;
  void clear_roundid();
  const std::string& roundid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roundid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roundid();
  PROTOBUF_NODISCARD std::string* release_roundid();
  void set_allocated_roundid(std::string* roundid);
  private:
  const std::string& _internal_roundid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roundid(const std::string& value);
  std::string* _internal_mutable_roundid();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // double refundAmount = 4;
  void clear_refundamount();
  double refundamount() const;
  void set_refundamount(double value);
  private:
  double _internal_refundamount() const;
  void _internal_set_refundamount(double value);
  public:

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // int32 playType = 6;
  void clear_playtype();
  int32_t playtype() const;
  void set_playtype(int32_t value);
  private:
  int32_t _internal_playtype() const;
  void _internal_set_playtype(int32_t value);
  public:

  // double balance = 5;
  void clear_balance();
  double balance() const;
  void set_balance(double value);
  private:
  double _internal_balance() const;
  void _internal_set_balance(double value);
  public:

  // @@protoc_insertion_point(class_scope:proto.MinesCancelBetRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roundid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    double refundamount_;
    int32_t code_;
    int32_t playtype_;
    double balance_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class MinesStartJettonNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.MinesStartJettonNotify) */ {
 public:
  inline MinesStartJettonNotify() : MinesStartJettonNotify(nullptr) {}
  ~MinesStartJettonNotify() override;
  explicit PROTOBUF_CONSTEXPR MinesStartJettonNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MinesStartJettonNotify(const MinesStartJettonNotify& from);
  MinesStartJettonNotify(MinesStartJettonNotify&& from) noexcept
    : MinesStartJettonNotify() {
    *this = ::std::move(from);
  }

  inline MinesStartJettonNotify& operator=(const MinesStartJettonNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline MinesStartJettonNotify& operator=(MinesStartJettonNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MinesStartJettonNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const MinesStartJettonNotify* internal_default_instance() {
    return reinterpret_cast<const MinesStartJettonNotify*>(
               &_MinesStartJettonNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(MinesStartJettonNotify& a, MinesStartJettonNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(MinesStartJettonNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MinesStartJettonNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MinesStartJettonNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MinesStartJettonNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MinesStartJettonNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MinesStartJettonNotify& from) {
    MinesStartJettonNotify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MinesStartJettonNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.MinesStartJettonNotify";
  }
  protected:
  explicit MinesStartJettonNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoundIdFieldNumber = 1,
    kGametypeFieldNumber = 2,
    kDurationFieldNumber = 3,
  };
  // string roundId = 1;
  void clear_roundid();
  const std::string& roundid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roundid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roundid();
  PROTOBUF_NODISCARD std::string* release_roundid();
  void set_allocated_roundid(std::string* roundid);
  private:
  const std::string& _internal_roundid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roundid(const std::string& value);
  std::string* _internal_mutable_roundid();
  public:

  // string gametype = 2;
  void clear_gametype();
  const std::string& gametype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gametype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gametype();
  PROTOBUF_NODISCARD std::string* release_gametype();
  void set_allocated_gametype(std::string* gametype);
  private:
  const std::string& _internal_gametype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gametype(const std::string& value);
  std::string* _internal_mutable_gametype();
  public:

  // int64 duration = 3;
  void clear_duration();
  int64_t duration() const;
  void set_duration(int64_t value);
  private:
  int64_t _internal_duration() const;
  void _internal_set_duration(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.MinesStartJettonNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roundid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gametype_;
    int64_t duration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GameStopJettonNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.GameStopJettonNotify) */ {
 public:
  inline GameStopJettonNotify() : GameStopJettonNotify(nullptr) {}
  ~GameStopJettonNotify() override;
  explicit PROTOBUF_CONSTEXPR GameStopJettonNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameStopJettonNotify(const GameStopJettonNotify& from);
  GameStopJettonNotify(GameStopJettonNotify&& from) noexcept
    : GameStopJettonNotify() {
    *this = ::std::move(from);
  }

  inline GameStopJettonNotify& operator=(const GameStopJettonNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameStopJettonNotify& operator=(GameStopJettonNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameStopJettonNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameStopJettonNotify* internal_default_instance() {
    return reinterpret_cast<const GameStopJettonNotify*>(
               &_GameStopJettonNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GameStopJettonNotify& a, GameStopJettonNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(GameStopJettonNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameStopJettonNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameStopJettonNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameStopJettonNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameStopJettonNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameStopJettonNotify& from) {
    GameStopJettonNotify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameStopJettonNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.GameStopJettonNotify";
  }
  protected:
  explicit GameStopJettonNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoundIdFieldNumber = 1,
    kGameTypeFieldNumber = 2,
    kStopTimeFieldNumber = 3,
  };
  // string roundId = 1;
  void clear_roundid();
  const std::string& roundid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roundid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roundid();
  PROTOBUF_NODISCARD std::string* release_roundid();
  void set_allocated_roundid(std::string* roundid);
  private:
  const std::string& _internal_roundid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roundid(const std::string& value);
  std::string* _internal_mutable_roundid();
  public:

  // string gameType = 2;
  void clear_gametype();
  const std::string& gametype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gametype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gametype();
  PROTOBUF_NODISCARD std::string* release_gametype();
  void set_allocated_gametype(std::string* gametype);
  private:
  const std::string& _internal_gametype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gametype(const std::string& value);
  std::string* _internal_mutable_gametype();
  public:

  // int64 stopTime = 3;
  void clear_stoptime();
  int64_t stoptime() const;
  void set_stoptime(int64_t value);
  private:
  int64_t _internal_stoptime() const;
  void _internal_set_stoptime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:proto.GameStopJettonNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roundid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gametype_;
    int64_t stoptime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GameRankInfoNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proto.GameRankInfoNotify) */ {
 public:
  inline GameRankInfoNotify() : GameRankInfoNotify(nullptr) {}
  ~GameRankInfoNotify() override;
  explicit PROTOBUF_CONSTEXPR GameRankInfoNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameRankInfoNotify(const GameRankInfoNotify& from);
  GameRankInfoNotify(GameRankInfoNotify&& from) noexcept
    : GameRankInfoNotify() {
    *this = ::std::move(from);
  }

  inline GameRankInfoNotify& operator=(const GameRankInfoNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameRankInfoNotify& operator=(GameRankInfoNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameRankInfoNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameRankInfoNotify* internal_default_instance() {
    return reinterpret_cast<const GameRankInfoNotify*>(
               &_GameRankInfoNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GameRankInfoNotify& a, GameRankInfoNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(GameRankInfoNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameRankInfoNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameRankInfoNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameRankInfoNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameRankInfoNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameRankInfoNotify& from) {
    GameRankInfoNotify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameRankInfoNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.GameRankInfoNotify";
  }
  protected:
  explicit GameRankInfoNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 3,
    kRoundIdFieldNumber = 1,
    kGameTypeFieldNumber = 2,
  };
  // repeated .proto.PlayerInfoSnap players = 3;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::proto::PlayerInfoSnap* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PlayerInfoSnap >*
      mutable_players();
  private:
  const ::proto::PlayerInfoSnap& _internal_players(int index) const;
  ::proto::PlayerInfoSnap* _internal_add_players();
  public:
  const ::proto::PlayerInfoSnap& players(int index) const;
  ::proto::PlayerInfoSnap* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PlayerInfoSnap >&
      players() const;

  // string roundId = 1;
  void clear_roundid();
  const std::string& roundid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roundid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roundid();
  PROTOBUF_NODISCARD std::string* release_roundid();
  void set_allocated_roundid(std::string* roundid);
  private:
  const std::string& _internal_roundid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roundid(const std::string& value);
  std::string* _internal_mutable_roundid();
  public:

  // string gameType = 2;
  void clear_gametype();
  const std::string& gametype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gametype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gametype();
  PROTOBUF_NODISCARD std::string* release_gametype();
  void set_allocated_gametype(std::string* gametype);
  private:
  const std::string& _internal_gametype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gametype(const std::string& value);
  std::string* _internal_mutable_gametype();
  public:

  // @@protoc_insertion_point(class_scope:proto.GameRankInfoNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PlayerInfoSnap > players_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roundid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gametype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class ConnClose final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:proto.ConnClose) */ {
 public:
  inline ConnClose() : ConnClose(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ConnClose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnClose(const ConnClose& from);
  ConnClose(ConnClose&& from) noexcept
    : ConnClose() {
    *this = ::std::move(from);
  }

  inline ConnClose& operator=(const ConnClose& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnClose& operator=(ConnClose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnClose& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnClose* internal_default_instance() {
    return reinterpret_cast<const ConnClose*>(
               &_ConnClose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ConnClose& a, ConnClose& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnClose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnClose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnClose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnClose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ConnClose& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ConnClose& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proto.ConnClose";
  }
  protected:
  explicit ConnClose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.ConnClose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_game_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BetRecord

// int32 playType = 1;
inline void BetRecord::clear_playtype() {
  _impl_.playtype_ = 0;
}
inline int32_t BetRecord::_internal_playtype() const {
  return _impl_.playtype_;
}
inline int32_t BetRecord::playtype() const {
  // @@protoc_insertion_point(field_get:proto.BetRecord.playType)
  return _internal_playtype();
}
inline void BetRecord::_internal_set_playtype(int32_t value) {
  
  _impl_.playtype_ = value;
}
inline void BetRecord::set_playtype(int32_t value) {
  _internal_set_playtype(value);
  // @@protoc_insertion_point(field_set:proto.BetRecord.playType)
}

// double amount = 2;
inline void BetRecord::clear_amount() {
  _impl_.amount_ = 0;
}
inline double BetRecord::_internal_amount() const {
  return _impl_.amount_;
}
inline double BetRecord::amount() const {
  // @@protoc_insertion_point(field_get:proto.BetRecord.amount)
  return _internal_amount();
}
inline void BetRecord::_internal_set_amount(double value) {
  
  _impl_.amount_ = value;
}
inline void BetRecord::set_amount(double value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:proto.BetRecord.amount)
}

// -------------------------------------------------------------------

// ReckonRecord

// int32 playType = 1;
inline void ReckonRecord::clear_playtype() {
  _impl_.playtype_ = 0;
}
inline int32_t ReckonRecord::_internal_playtype() const {
  return _impl_.playtype_;
}
inline int32_t ReckonRecord::playtype() const {
  // @@protoc_insertion_point(field_get:proto.ReckonRecord.playType)
  return _internal_playtype();
}
inline void ReckonRecord::_internal_set_playtype(int32_t value) {
  
  _impl_.playtype_ = value;
}
inline void ReckonRecord::set_playtype(int32_t value) {
  _internal_set_playtype(value);
  // @@protoc_insertion_point(field_set:proto.ReckonRecord.playType)
}

// double amount = 2;
inline void ReckonRecord::clear_amount() {
  _impl_.amount_ = 0;
}
inline double ReckonRecord::_internal_amount() const {
  return _impl_.amount_;
}
inline double ReckonRecord::amount() const {
  // @@protoc_insertion_point(field_get:proto.ReckonRecord.amount)
  return _internal_amount();
}
inline void ReckonRecord::_internal_set_amount(double value) {
  
  _impl_.amount_ = value;
}
inline void ReckonRecord::set_amount(double value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:proto.ReckonRecord.amount)
}

// double multi = 3;
inline void ReckonRecord::clear_multi() {
  _impl_.multi_ = 0;
}
inline double ReckonRecord::_internal_multi() const {
  return _impl_.multi_;
}
inline double ReckonRecord::multi() const {
  // @@protoc_insertion_point(field_get:proto.ReckonRecord.multi)
  return _internal_multi();
}
inline void ReckonRecord::_internal_set_multi(double value) {
  
  _impl_.multi_ = value;
}
inline void ReckonRecord::set_multi(double value) {
  _internal_set_multi(value);
  // @@protoc_insertion_point(field_set:proto.ReckonRecord.multi)
}

// -------------------------------------------------------------------

// PlayerInfo

// string username = 1;
inline void PlayerInfo::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& PlayerInfo::username() const {
  // @@protoc_insertion_point(field_get:proto.PlayerInfo.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.PlayerInfo.username)
}
inline std::string* PlayerInfo::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:proto.PlayerInfo.username)
  return _s;
}
inline const std::string& PlayerInfo::_internal_username() const {
  return _impl_.username_.Get();
}
inline void PlayerInfo::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_username() {
  // @@protoc_insertion_point(field_release:proto.PlayerInfo.username)
  return _impl_.username_.Release();
}
inline void PlayerInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.PlayerInfo.username)
}

// string nickname = 2;
inline void PlayerInfo::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& PlayerInfo::nickname() const {
  // @@protoc_insertion_point(field_get:proto.PlayerInfo.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.PlayerInfo.nickname)
}
inline std::string* PlayerInfo::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:proto.PlayerInfo.nickname)
  return _s;
}
inline const std::string& PlayerInfo::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void PlayerInfo::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_nickname() {
  // @@protoc_insertion_point(field_release:proto.PlayerInfo.nickname)
  return _impl_.nickname_.Release();
}
inline void PlayerInfo::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.PlayerInfo.nickname)
}

// string avatar = 3;
inline void PlayerInfo::clear_avatar() {
  _impl_.avatar_.ClearToEmpty();
}
inline const std::string& PlayerInfo::avatar() const {
  // @@protoc_insertion_point(field_get:proto.PlayerInfo.avatar)
  return _internal_avatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_avatar(ArgT0&& arg0, ArgT... args) {
 
 _impl_.avatar_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.PlayerInfo.avatar)
}
inline std::string* PlayerInfo::mutable_avatar() {
  std::string* _s = _internal_mutable_avatar();
  // @@protoc_insertion_point(field_mutable:proto.PlayerInfo.avatar)
  return _s;
}
inline const std::string& PlayerInfo::_internal_avatar() const {
  return _impl_.avatar_.Get();
}
inline void PlayerInfo::_internal_set_avatar(const std::string& value) {
  
  _impl_.avatar_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_avatar() {
  
  return _impl_.avatar_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_avatar() {
  // @@protoc_insertion_point(field_release:proto.PlayerInfo.avatar)
  return _impl_.avatar_.Release();
}
inline void PlayerInfo::set_allocated_avatar(std::string* avatar) {
  if (avatar != nullptr) {
    
  } else {
    
  }
  _impl_.avatar_.SetAllocated(avatar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_.IsDefault()) {
    _impl_.avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.PlayerInfo.avatar)
}

// int32 vip = 4;
inline void PlayerInfo::clear_vip() {
  _impl_.vip_ = 0;
}
inline int32_t PlayerInfo::_internal_vip() const {
  return _impl_.vip_;
}
inline int32_t PlayerInfo::vip() const {
  // @@protoc_insertion_point(field_get:proto.PlayerInfo.vip)
  return _internal_vip();
}
inline void PlayerInfo::_internal_set_vip(int32_t value) {
  
  _impl_.vip_ = value;
}
inline void PlayerInfo::set_vip(int32_t value) {
  _internal_set_vip(value);
  // @@protoc_insertion_point(field_set:proto.PlayerInfo.vip)
}

// double balance = 5;
inline void PlayerInfo::clear_balance() {
  _impl_.balance_ = 0;
}
inline double PlayerInfo::_internal_balance() const {
  return _impl_.balance_;
}
inline double PlayerInfo::balance() const {
  // @@protoc_insertion_point(field_get:proto.PlayerInfo.balance)
  return _internal_balance();
}
inline void PlayerInfo::_internal_set_balance(double value) {
  
  _impl_.balance_ = value;
}
inline void PlayerInfo::set_balance(double value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:proto.PlayerInfo.balance)
}

// string currency = 6;
inline void PlayerInfo::clear_currency() {
  _impl_.currency_.ClearToEmpty();
}
inline const std::string& PlayerInfo::currency() const {
  // @@protoc_insertion_point(field_get:proto.PlayerInfo.currency)
  return _internal_currency();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_currency(ArgT0&& arg0, ArgT... args) {
 
 _impl_.currency_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.PlayerInfo.currency)
}
inline std::string* PlayerInfo::mutable_currency() {
  std::string* _s = _internal_mutable_currency();
  // @@protoc_insertion_point(field_mutable:proto.PlayerInfo.currency)
  return _s;
}
inline const std::string& PlayerInfo::_internal_currency() const {
  return _impl_.currency_.Get();
}
inline void PlayerInfo::_internal_set_currency(const std::string& value) {
  
  _impl_.currency_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_currency() {
  
  return _impl_.currency_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_currency() {
  // @@protoc_insertion_point(field_release:proto.PlayerInfo.currency)
  return _impl_.currency_.Release();
}
inline void PlayerInfo::set_allocated_currency(std::string* currency) {
  if (currency != nullptr) {
    
  } else {
    
  }
  _impl_.currency_.SetAllocated(currency, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currency_.IsDefault()) {
    _impl_.currency_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.PlayerInfo.currency)
}

// string loginname = 7;
inline void PlayerInfo::clear_loginname() {
  _impl_.loginname_.ClearToEmpty();
}
inline const std::string& PlayerInfo::loginname() const {
  // @@protoc_insertion_point(field_get:proto.PlayerInfo.loginname)
  return _internal_loginname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_loginname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loginname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.PlayerInfo.loginname)
}
inline std::string* PlayerInfo::mutable_loginname() {
  std::string* _s = _internal_mutable_loginname();
  // @@protoc_insertion_point(field_mutable:proto.PlayerInfo.loginname)
  return _s;
}
inline const std::string& PlayerInfo::_internal_loginname() const {
  return _impl_.loginname_.Get();
}
inline void PlayerInfo::_internal_set_loginname(const std::string& value) {
  
  _impl_.loginname_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_loginname() {
  
  return _impl_.loginname_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_loginname() {
  // @@protoc_insertion_point(field_release:proto.PlayerInfo.loginname)
  return _impl_.loginname_.Release();
}
inline void PlayerInfo::set_allocated_loginname(std::string* loginname) {
  if (loginname != nullptr) {
    
  } else {
    
  }
  _impl_.loginname_.SetAllocated(loginname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loginname_.IsDefault()) {
    _impl_.loginname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.PlayerInfo.loginname)
}

// -------------------------------------------------------------------

// PlayerInfoSnap

// .proto.PlayerInfo info = 1;
inline bool PlayerInfoSnap::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool PlayerInfoSnap::has_info() const {
  return _internal_has_info();
}
inline void PlayerInfoSnap::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::proto::PlayerInfo& PlayerInfoSnap::_internal_info() const {
  const ::proto::PlayerInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::PlayerInfo&>(
      ::proto::_PlayerInfo_default_instance_);
}
inline const ::proto::PlayerInfo& PlayerInfoSnap::info() const {
  // @@protoc_insertion_point(field_get:proto.PlayerInfoSnap.info)
  return _internal_info();
}
inline void PlayerInfoSnap::unsafe_arena_set_allocated_info(
    ::proto::PlayerInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.PlayerInfoSnap.info)
}
inline ::proto::PlayerInfo* PlayerInfoSnap::release_info() {
  
  ::proto::PlayerInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::PlayerInfo* PlayerInfoSnap::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:proto.PlayerInfoSnap.info)
  
  ::proto::PlayerInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::proto::PlayerInfo* PlayerInfoSnap::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::PlayerInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::proto::PlayerInfo* PlayerInfoSnap::mutable_info() {
  ::proto::PlayerInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:proto.PlayerInfoSnap.info)
  return _msg;
}
inline void PlayerInfoSnap::set_allocated_info(::proto::PlayerInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:proto.PlayerInfoSnap.info)
}

// repeated .proto.BetRecord bets = 2;
inline int PlayerInfoSnap::_internal_bets_size() const {
  return _impl_.bets_.size();
}
inline int PlayerInfoSnap::bets_size() const {
  return _internal_bets_size();
}
inline void PlayerInfoSnap::clear_bets() {
  _impl_.bets_.Clear();
}
inline ::proto::BetRecord* PlayerInfoSnap::mutable_bets(int index) {
  // @@protoc_insertion_point(field_mutable:proto.PlayerInfoSnap.bets)
  return _impl_.bets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::BetRecord >*
PlayerInfoSnap::mutable_bets() {
  // @@protoc_insertion_point(field_mutable_list:proto.PlayerInfoSnap.bets)
  return &_impl_.bets_;
}
inline const ::proto::BetRecord& PlayerInfoSnap::_internal_bets(int index) const {
  return _impl_.bets_.Get(index);
}
inline const ::proto::BetRecord& PlayerInfoSnap::bets(int index) const {
  // @@protoc_insertion_point(field_get:proto.PlayerInfoSnap.bets)
  return _internal_bets(index);
}
inline ::proto::BetRecord* PlayerInfoSnap::_internal_add_bets() {
  return _impl_.bets_.Add();
}
inline ::proto::BetRecord* PlayerInfoSnap::add_bets() {
  ::proto::BetRecord* _add = _internal_add_bets();
  // @@protoc_insertion_point(field_add:proto.PlayerInfoSnap.bets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::BetRecord >&
PlayerInfoSnap::bets() const {
  // @@protoc_insertion_point(field_list:proto.PlayerInfoSnap.bets)
  return _impl_.bets_;
}

// repeated .proto.ReckonRecord reckons = 3;
inline int PlayerInfoSnap::_internal_reckons_size() const {
  return _impl_.reckons_.size();
}
inline int PlayerInfoSnap::reckons_size() const {
  return _internal_reckons_size();
}
inline void PlayerInfoSnap::clear_reckons() {
  _impl_.reckons_.Clear();
}
inline ::proto::ReckonRecord* PlayerInfoSnap::mutable_reckons(int index) {
  // @@protoc_insertion_point(field_mutable:proto.PlayerInfoSnap.reckons)
  return _impl_.reckons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ReckonRecord >*
PlayerInfoSnap::mutable_reckons() {
  // @@protoc_insertion_point(field_mutable_list:proto.PlayerInfoSnap.reckons)
  return &_impl_.reckons_;
}
inline const ::proto::ReckonRecord& PlayerInfoSnap::_internal_reckons(int index) const {
  return _impl_.reckons_.Get(index);
}
inline const ::proto::ReckonRecord& PlayerInfoSnap::reckons(int index) const {
  // @@protoc_insertion_point(field_get:proto.PlayerInfoSnap.reckons)
  return _internal_reckons(index);
}
inline ::proto::ReckonRecord* PlayerInfoSnap::_internal_add_reckons() {
  return _impl_.reckons_.Add();
}
inline ::proto::ReckonRecord* PlayerInfoSnap::add_reckons() {
  ::proto::ReckonRecord* _add = _internal_add_reckons();
  // @@protoc_insertion_point(field_add:proto.PlayerInfoSnap.reckons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::ReckonRecord >&
PlayerInfoSnap::reckons() const {
  // @@protoc_insertion_point(field_list:proto.PlayerInfoSnap.reckons)
  return _impl_.reckons_;
}

// -------------------------------------------------------------------

// GameResult

// int32 result = 1;
inline void GameResult::clear_result() {
  _impl_.result_ = 0;
}
inline int32_t GameResult::_internal_result() const {
  return _impl_.result_;
}
inline int32_t GameResult::result() const {
  // @@protoc_insertion_point(field_get:proto.GameResult.result)
  return _internal_result();
}
inline void GameResult::_internal_set_result(int32_t value) {
  
  _impl_.result_ = value;
}
inline void GameResult::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:proto.GameResult.result)
}

// double multi = 2;
inline void GameResult::clear_multi() {
  _impl_.multi_ = 0;
}
inline double GameResult::_internal_multi() const {
  return _impl_.multi_;
}
inline double GameResult::multi() const {
  // @@protoc_insertion_point(field_get:proto.GameResult.multi)
  return _internal_multi();
}
inline void GameResult::_internal_set_multi(double value) {
  
  _impl_.multi_ = value;
}
inline void GameResult::set_multi(double value) {
  _internal_set_multi(value);
  // @@protoc_insertion_point(field_set:proto.GameResult.multi)
}

// int32 index = 3;
inline void GameResult::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t GameResult::_internal_index() const {
  return _impl_.index_;
}
inline int32_t GameResult::index() const {
  // @@protoc_insertion_point(field_get:proto.GameResult.index)
  return _internal_index();
}
inline void GameResult::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void GameResult::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:proto.GameResult.index)
}

// -------------------------------------------------------------------

// HeartBeat

// int64 timestamp = 1;
inline void HeartBeat::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t HeartBeat::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t HeartBeat::timestamp() const {
  // @@protoc_insertion_point(field_get:proto.HeartBeat.timestamp)
  return _internal_timestamp();
}
inline void HeartBeat::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void HeartBeat::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:proto.HeartBeat.timestamp)
}

// -------------------------------------------------------------------

// LoginReq

// string loginname = 1;
inline void LoginReq::clear_loginname() {
  _impl_.loginname_.ClearToEmpty();
}
inline const std::string& LoginReq::loginname() const {
  // @@protoc_insertion_point(field_get:proto.LoginReq.loginname)
  return _internal_loginname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_loginname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loginname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LoginReq.loginname)
}
inline std::string* LoginReq::mutable_loginname() {
  std::string* _s = _internal_mutable_loginname();
  // @@protoc_insertion_point(field_mutable:proto.LoginReq.loginname)
  return _s;
}
inline const std::string& LoginReq::_internal_loginname() const {
  return _impl_.loginname_.Get();
}
inline void LoginReq::_internal_set_loginname(const std::string& value) {
  
  _impl_.loginname_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_loginname() {
  
  return _impl_.loginname_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReq::release_loginname() {
  // @@protoc_insertion_point(field_release:proto.LoginReq.loginname)
  return _impl_.loginname_.Release();
}
inline void LoginReq::set_allocated_loginname(std::string* loginname) {
  if (loginname != nullptr) {
    
  } else {
    
  }
  _impl_.loginname_.SetAllocated(loginname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loginname_.IsDefault()) {
    _impl_.loginname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LoginReq.loginname)
}

// string token = 2;
inline void LoginReq::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& LoginReq::token() const {
  // @@protoc_insertion_point(field_get:proto.LoginReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LoginReq.token)
}
inline std::string* LoginReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:proto.LoginReq.token)
  return _s;
}
inline const std::string& LoginReq::_internal_token() const {
  return _impl_.token_.Get();
}
inline void LoginReq::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReq::release_token() {
  // @@protoc_insertion_point(field_release:proto.LoginReq.token)
  return _impl_.token_.Release();
}
inline void LoginReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LoginReq.token)
}

// string game_type = 3;
inline void LoginReq::clear_game_type() {
  _impl_.game_type_.ClearToEmpty();
}
inline const std::string& LoginReq::game_type() const {
  // @@protoc_insertion_point(field_get:proto.LoginReq.game_type)
  return _internal_game_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_game_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.game_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LoginReq.game_type)
}
inline std::string* LoginReq::mutable_game_type() {
  std::string* _s = _internal_mutable_game_type();
  // @@protoc_insertion_point(field_mutable:proto.LoginReq.game_type)
  return _s;
}
inline const std::string& LoginReq::_internal_game_type() const {
  return _impl_.game_type_.Get();
}
inline void LoginReq::_internal_set_game_type(const std::string& value) {
  
  _impl_.game_type_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_game_type() {
  
  return _impl_.game_type_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReq::release_game_type() {
  // @@protoc_insertion_point(field_release:proto.LoginReq.game_type)
  return _impl_.game_type_.Release();
}
inline void LoginReq::set_allocated_game_type(std::string* game_type) {
  if (game_type != nullptr) {
    
  } else {
    
  }
  _impl_.game_type_.SetAllocated(game_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_type_.IsDefault()) {
    _impl_.game_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LoginReq.game_type)
}

// uint32 version = 4;
inline void LoginReq::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t LoginReq::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t LoginReq::version() const {
  // @@protoc_insertion_point(field_get:proto.LoginReq.version)
  return _internal_version();
}
inline void LoginReq::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void LoginReq::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:proto.LoginReq.version)
}

// string client_ip = 5;
inline void LoginReq::clear_client_ip() {
  _impl_.client_ip_.ClearToEmpty();
}
inline const std::string& LoginReq::client_ip() const {
  // @@protoc_insertion_point(field_get:proto.LoginReq.client_ip)
  return _internal_client_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_client_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LoginReq.client_ip)
}
inline std::string* LoginReq::mutable_client_ip() {
  std::string* _s = _internal_mutable_client_ip();
  // @@protoc_insertion_point(field_mutable:proto.LoginReq.client_ip)
  return _s;
}
inline const std::string& LoginReq::_internal_client_ip() const {
  return _impl_.client_ip_.Get();
}
inline void LoginReq::_internal_set_client_ip(const std::string& value) {
  
  _impl_.client_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_client_ip() {
  
  return _impl_.client_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReq::release_client_ip() {
  // @@protoc_insertion_point(field_release:proto.LoginReq.client_ip)
  return _impl_.client_ip_.Release();
}
inline void LoginReq::set_allocated_client_ip(std::string* client_ip) {
  if (client_ip != nullptr) {
    
  } else {
    
  }
  _impl_.client_ip_.SetAllocated(client_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_ip_.IsDefault()) {
    _impl_.client_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LoginReq.client_ip)
}

// -------------------------------------------------------------------

// LoginResp

// string loginname = 1;
inline void LoginResp::clear_loginname() {
  _impl_.loginname_.ClearToEmpty();
}
inline const std::string& LoginResp::loginname() const {
  // @@protoc_insertion_point(field_get:proto.LoginResp.loginname)
  return _internal_loginname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResp::set_loginname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loginname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LoginResp.loginname)
}
inline std::string* LoginResp::mutable_loginname() {
  std::string* _s = _internal_mutable_loginname();
  // @@protoc_insertion_point(field_mutable:proto.LoginResp.loginname)
  return _s;
}
inline const std::string& LoginResp::_internal_loginname() const {
  return _impl_.loginname_.Get();
}
inline void LoginResp::_internal_set_loginname(const std::string& value) {
  
  _impl_.loginname_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResp::_internal_mutable_loginname() {
  
  return _impl_.loginname_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResp::release_loginname() {
  // @@protoc_insertion_point(field_release:proto.LoginResp.loginname)
  return _impl_.loginname_.Release();
}
inline void LoginResp::set_allocated_loginname(std::string* loginname) {
  if (loginname != nullptr) {
    
  } else {
    
  }
  _impl_.loginname_.SetAllocated(loginname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loginname_.IsDefault()) {
    _impl_.loginname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LoginResp.loginname)
}

// int32 code = 2;
inline void LoginResp::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t LoginResp::_internal_code() const {
  return _impl_.code_;
}
inline int32_t LoginResp::code() const {
  // @@protoc_insertion_point(field_get:proto.LoginResp.code)
  return _internal_code();
}
inline void LoginResp::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void LoginResp::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:proto.LoginResp.code)
}

// string message = 3;
inline void LoginResp::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LoginResp::message() const {
  // @@protoc_insertion_point(field_get:proto.LoginResp.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResp::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LoginResp.message)
}
inline std::string* LoginResp::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:proto.LoginResp.message)
  return _s;
}
inline const std::string& LoginResp::_internal_message() const {
  return _impl_.message_.Get();
}
inline void LoginResp::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResp::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResp::release_message() {
  // @@protoc_insertion_point(field_release:proto.LoginResp.message)
  return _impl_.message_.Release();
}
inline void LoginResp::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LoginResp.message)
}

// .proto.PlayerInfo info = 4;
inline bool LoginResp::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool LoginResp::has_info() const {
  return _internal_has_info();
}
inline void LoginResp::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
inline const ::proto::PlayerInfo& LoginResp::_internal_info() const {
  const ::proto::PlayerInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::PlayerInfo&>(
      ::proto::_PlayerInfo_default_instance_);
}
inline const ::proto::PlayerInfo& LoginResp::info() const {
  // @@protoc_insertion_point(field_get:proto.LoginResp.info)
  return _internal_info();
}
inline void LoginResp::unsafe_arena_set_allocated_info(
    ::proto::PlayerInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.LoginResp.info)
}
inline ::proto::PlayerInfo* LoginResp::release_info() {
  
  ::proto::PlayerInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::PlayerInfo* LoginResp::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:proto.LoginResp.info)
  
  ::proto::PlayerInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::proto::PlayerInfo* LoginResp::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::PlayerInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::proto::PlayerInfo* LoginResp::mutable_info() {
  ::proto::PlayerInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:proto.LoginResp.info)
  return _msg;
}
inline void LoginResp::set_allocated_info(::proto::PlayerInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:proto.LoginResp.info)
}

// -------------------------------------------------------------------

// LogoutReq

// string loginname = 1;
inline void LogoutReq::clear_loginname() {
  _impl_.loginname_.ClearToEmpty();
}
inline const std::string& LogoutReq::loginname() const {
  // @@protoc_insertion_point(field_get:proto.LogoutReq.loginname)
  return _internal_loginname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutReq::set_loginname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loginname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LogoutReq.loginname)
}
inline std::string* LogoutReq::mutable_loginname() {
  std::string* _s = _internal_mutable_loginname();
  // @@protoc_insertion_point(field_mutable:proto.LogoutReq.loginname)
  return _s;
}
inline const std::string& LogoutReq::_internal_loginname() const {
  return _impl_.loginname_.Get();
}
inline void LogoutReq::_internal_set_loginname(const std::string& value) {
  
  _impl_.loginname_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutReq::_internal_mutable_loginname() {
  
  return _impl_.loginname_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutReq::release_loginname() {
  // @@protoc_insertion_point(field_release:proto.LogoutReq.loginname)
  return _impl_.loginname_.Release();
}
inline void LogoutReq::set_allocated_loginname(std::string* loginname) {
  if (loginname != nullptr) {
    
  } else {
    
  }
  _impl_.loginname_.SetAllocated(loginname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loginname_.IsDefault()) {
    _impl_.loginname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LogoutReq.loginname)
}

// -------------------------------------------------------------------

// LogoutRes

// string loginname = 1;
inline void LogoutRes::clear_loginname() {
  _impl_.loginname_.ClearToEmpty();
}
inline const std::string& LogoutRes::loginname() const {
  // @@protoc_insertion_point(field_get:proto.LogoutRes.loginname)
  return _internal_loginname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutRes::set_loginname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loginname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LogoutRes.loginname)
}
inline std::string* LogoutRes::mutable_loginname() {
  std::string* _s = _internal_mutable_loginname();
  // @@protoc_insertion_point(field_mutable:proto.LogoutRes.loginname)
  return _s;
}
inline const std::string& LogoutRes::_internal_loginname() const {
  return _impl_.loginname_.Get();
}
inline void LogoutRes::_internal_set_loginname(const std::string& value) {
  
  _impl_.loginname_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutRes::_internal_mutable_loginname() {
  
  return _impl_.loginname_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutRes::release_loginname() {
  // @@protoc_insertion_point(field_release:proto.LogoutRes.loginname)
  return _impl_.loginname_.Release();
}
inline void LogoutRes::set_allocated_loginname(std::string* loginname) {
  if (loginname != nullptr) {
    
  } else {
    
  }
  _impl_.loginname_.SetAllocated(loginname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loginname_.IsDefault()) {
    _impl_.loginname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LogoutRes.loginname)
}

// int32 code = 2;
inline void LogoutRes::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t LogoutRes::_internal_code() const {
  return _impl_.code_;
}
inline int32_t LogoutRes::code() const {
  // @@protoc_insertion_point(field_get:proto.LogoutRes.code)
  return _internal_code();
}
inline void LogoutRes::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void LogoutRes::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:proto.LogoutRes.code)
}

// string msg = 3;
inline void LogoutRes::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& LogoutRes::msg() const {
  // @@protoc_insertion_point(field_get:proto.LogoutRes.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutRes::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.LogoutRes.msg)
}
inline std::string* LogoutRes::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:proto.LogoutRes.msg)
  return _s;
}
inline const std::string& LogoutRes::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void LogoutRes::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutRes::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutRes::release_msg() {
  // @@protoc_insertion_point(field_release:proto.LogoutRes.msg)
  return _impl_.msg_.Release();
}
inline void LogoutRes::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.LogoutRes.msg)
}

// -------------------------------------------------------------------

// KickPlayerNotify

// string sessionId = 1;
inline void KickPlayerNotify::clear_sessionid() {
  _impl_.sessionid_.ClearToEmpty();
}
inline const std::string& KickPlayerNotify::sessionid() const {
  // @@protoc_insertion_point(field_get:proto.KickPlayerNotify.sessionId)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KickPlayerNotify::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sessionid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.KickPlayerNotify.sessionId)
}
inline std::string* KickPlayerNotify::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:proto.KickPlayerNotify.sessionId)
  return _s;
}
inline const std::string& KickPlayerNotify::_internal_sessionid() const {
  return _impl_.sessionid_.Get();
}
inline void KickPlayerNotify::_internal_set_sessionid(const std::string& value) {
  
  _impl_.sessionid_.Set(value, GetArenaForAllocation());
}
inline std::string* KickPlayerNotify::_internal_mutable_sessionid() {
  
  return _impl_.sessionid_.Mutable(GetArenaForAllocation());
}
inline std::string* KickPlayerNotify::release_sessionid() {
  // @@protoc_insertion_point(field_release:proto.KickPlayerNotify.sessionId)
  return _impl_.sessionid_.Release();
}
inline void KickPlayerNotify::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  _impl_.sessionid_.SetAllocated(sessionid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sessionid_.IsDefault()) {
    _impl_.sessionid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.KickPlayerNotify.sessionId)
}

// int32 reason = 2;
inline void KickPlayerNotify::clear_reason() {
  _impl_.reason_ = 0;
}
inline int32_t KickPlayerNotify::_internal_reason() const {
  return _impl_.reason_;
}
inline int32_t KickPlayerNotify::reason() const {
  // @@protoc_insertion_point(field_get:proto.KickPlayerNotify.reason)
  return _internal_reason();
}
inline void KickPlayerNotify::_internal_set_reason(int32_t value) {
  
  _impl_.reason_ = value;
}
inline void KickPlayerNotify::set_reason(int32_t value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:proto.KickPlayerNotify.reason)
}

// -------------------------------------------------------------------

// GameSnapshotNotify

// string roundId = 1;
inline void GameSnapshotNotify::clear_roundid() {
  _impl_.roundid_.ClearToEmpty();
}
inline const std::string& GameSnapshotNotify::roundid() const {
  // @@protoc_insertion_point(field_get:proto.GameSnapshotNotify.roundId)
  return _internal_roundid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSnapshotNotify::set_roundid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roundid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.GameSnapshotNotify.roundId)
}
inline std::string* GameSnapshotNotify::mutable_roundid() {
  std::string* _s = _internal_mutable_roundid();
  // @@protoc_insertion_point(field_mutable:proto.GameSnapshotNotify.roundId)
  return _s;
}
inline const std::string& GameSnapshotNotify::_internal_roundid() const {
  return _impl_.roundid_.Get();
}
inline void GameSnapshotNotify::_internal_set_roundid(const std::string& value) {
  
  _impl_.roundid_.Set(value, GetArenaForAllocation());
}
inline std::string* GameSnapshotNotify::_internal_mutable_roundid() {
  
  return _impl_.roundid_.Mutable(GetArenaForAllocation());
}
inline std::string* GameSnapshotNotify::release_roundid() {
  // @@protoc_insertion_point(field_release:proto.GameSnapshotNotify.roundId)
  return _impl_.roundid_.Release();
}
inline void GameSnapshotNotify::set_allocated_roundid(std::string* roundid) {
  if (roundid != nullptr) {
    
  } else {
    
  }
  _impl_.roundid_.SetAllocated(roundid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roundid_.IsDefault()) {
    _impl_.roundid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.GameSnapshotNotify.roundId)
}

// string gameType = 2;
inline void GameSnapshotNotify::clear_gametype() {
  _impl_.gametype_.ClearToEmpty();
}
inline const std::string& GameSnapshotNotify::gametype() const {
  // @@protoc_insertion_point(field_get:proto.GameSnapshotNotify.gameType)
  return _internal_gametype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameSnapshotNotify::set_gametype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gametype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.GameSnapshotNotify.gameType)
}
inline std::string* GameSnapshotNotify::mutable_gametype() {
  std::string* _s = _internal_mutable_gametype();
  // @@protoc_insertion_point(field_mutable:proto.GameSnapshotNotify.gameType)
  return _s;
}
inline const std::string& GameSnapshotNotify::_internal_gametype() const {
  return _impl_.gametype_.Get();
}
inline void GameSnapshotNotify::_internal_set_gametype(const std::string& value) {
  
  _impl_.gametype_.Set(value, GetArenaForAllocation());
}
inline std::string* GameSnapshotNotify::_internal_mutable_gametype() {
  
  return _impl_.gametype_.Mutable(GetArenaForAllocation());
}
inline std::string* GameSnapshotNotify::release_gametype() {
  // @@protoc_insertion_point(field_release:proto.GameSnapshotNotify.gameType)
  return _impl_.gametype_.Release();
}
inline void GameSnapshotNotify::set_allocated_gametype(std::string* gametype) {
  if (gametype != nullptr) {
    
  } else {
    
  }
  _impl_.gametype_.SetAllocated(gametype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gametype_.IsDefault()) {
    _impl_.gametype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.GameSnapshotNotify.gameType)
}

// int32 status = 3;
inline void GameSnapshotNotify::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t GameSnapshotNotify::_internal_status() const {
  return _impl_.status_;
}
inline int32_t GameSnapshotNotify::status() const {
  // @@protoc_insertion_point(field_get:proto.GameSnapshotNotify.status)
  return _internal_status();
}
inline void GameSnapshotNotify::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void GameSnapshotNotify::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:proto.GameSnapshotNotify.status)
}

// int64 remainTime = 4;
inline void GameSnapshotNotify::clear_remaintime() {
  _impl_.remaintime_ = int64_t{0};
}
inline int64_t GameSnapshotNotify::_internal_remaintime() const {
  return _impl_.remaintime_;
}
inline int64_t GameSnapshotNotify::remaintime() const {
  // @@protoc_insertion_point(field_get:proto.GameSnapshotNotify.remainTime)
  return _internal_remaintime();
}
inline void GameSnapshotNotify::_internal_set_remaintime(int64_t value) {
  
  _impl_.remaintime_ = value;
}
inline void GameSnapshotNotify::set_remaintime(int64_t value) {
  _internal_set_remaintime(value);
  // @@protoc_insertion_point(field_set:proto.GameSnapshotNotify.remainTime)
}

// int32 curIndex = 5;
inline void GameSnapshotNotify::clear_curindex() {
  _impl_.curindex_ = 0;
}
inline int32_t GameSnapshotNotify::_internal_curindex() const {
  return _impl_.curindex_;
}
inline int32_t GameSnapshotNotify::curindex() const {
  // @@protoc_insertion_point(field_get:proto.GameSnapshotNotify.curIndex)
  return _internal_curindex();
}
inline void GameSnapshotNotify::_internal_set_curindex(int32_t value) {
  
  _impl_.curindex_ = value;
}
inline void GameSnapshotNotify::set_curindex(int32_t value) {
  _internal_set_curindex(value);
  // @@protoc_insertion_point(field_set:proto.GameSnapshotNotify.curIndex)
}

// double curMulti = 6;
inline void GameSnapshotNotify::clear_curmulti() {
  _impl_.curmulti_ = 0;
}
inline double GameSnapshotNotify::_internal_curmulti() const {
  return _impl_.curmulti_;
}
inline double GameSnapshotNotify::curmulti() const {
  // @@protoc_insertion_point(field_get:proto.GameSnapshotNotify.curMulti)
  return _internal_curmulti();
}
inline void GameSnapshotNotify::_internal_set_curmulti(double value) {
  
  _impl_.curmulti_ = value;
}
inline void GameSnapshotNotify::set_curmulti(double value) {
  _internal_set_curmulti(value);
  // @@protoc_insertion_point(field_set:proto.GameSnapshotNotify.curMulti)
}

// repeated .proto.GameResult result = 7;
inline int GameSnapshotNotify::_internal_result_size() const {
  return _impl_.result_.size();
}
inline int GameSnapshotNotify::result_size() const {
  return _internal_result_size();
}
inline void GameSnapshotNotify::clear_result() {
  _impl_.result_.Clear();
}
inline ::proto::GameResult* GameSnapshotNotify::mutable_result(int index) {
  // @@protoc_insertion_point(field_mutable:proto.GameSnapshotNotify.result)
  return _impl_.result_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::GameResult >*
GameSnapshotNotify::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:proto.GameSnapshotNotify.result)
  return &_impl_.result_;
}
inline const ::proto::GameResult& GameSnapshotNotify::_internal_result(int index) const {
  return _impl_.result_.Get(index);
}
inline const ::proto::GameResult& GameSnapshotNotify::result(int index) const {
  // @@protoc_insertion_point(field_get:proto.GameSnapshotNotify.result)
  return _internal_result(index);
}
inline ::proto::GameResult* GameSnapshotNotify::_internal_add_result() {
  return _impl_.result_.Add();
}
inline ::proto::GameResult* GameSnapshotNotify::add_result() {
  ::proto::GameResult* _add = _internal_add_result();
  // @@protoc_insertion_point(field_add:proto.GameSnapshotNotify.result)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::GameResult >&
GameSnapshotNotify::result() const {
  // @@protoc_insertion_point(field_list:proto.GameSnapshotNotify.result)
  return _impl_.result_;
}

// -------------------------------------------------------------------

// MinesPlaceBetReq

// string loginname = 1;
inline void MinesPlaceBetReq::clear_loginname() {
  _impl_.loginname_.ClearToEmpty();
}
inline const std::string& MinesPlaceBetReq::loginname() const {
  // @@protoc_insertion_point(field_get:proto.MinesPlaceBetReq.loginname)
  return _internal_loginname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesPlaceBetReq::set_loginname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loginname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesPlaceBetReq.loginname)
}
inline std::string* MinesPlaceBetReq::mutable_loginname() {
  std::string* _s = _internal_mutable_loginname();
  // @@protoc_insertion_point(field_mutable:proto.MinesPlaceBetReq.loginname)
  return _s;
}
inline const std::string& MinesPlaceBetReq::_internal_loginname() const {
  return _impl_.loginname_.Get();
}
inline void MinesPlaceBetReq::_internal_set_loginname(const std::string& value) {
  
  _impl_.loginname_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesPlaceBetReq::_internal_mutable_loginname() {
  
  return _impl_.loginname_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesPlaceBetReq::release_loginname() {
  // @@protoc_insertion_point(field_release:proto.MinesPlaceBetReq.loginname)
  return _impl_.loginname_.Release();
}
inline void MinesPlaceBetReq::set_allocated_loginname(std::string* loginname) {
  if (loginname != nullptr) {
    
  } else {
    
  }
  _impl_.loginname_.SetAllocated(loginname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loginname_.IsDefault()) {
    _impl_.loginname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesPlaceBetReq.loginname)
}

// string roundId = 2;
inline void MinesPlaceBetReq::clear_roundid() {
  _impl_.roundid_.ClearToEmpty();
}
inline const std::string& MinesPlaceBetReq::roundid() const {
  // @@protoc_insertion_point(field_get:proto.MinesPlaceBetReq.roundId)
  return _internal_roundid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesPlaceBetReq::set_roundid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roundid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesPlaceBetReq.roundId)
}
inline std::string* MinesPlaceBetReq::mutable_roundid() {
  std::string* _s = _internal_mutable_roundid();
  // @@protoc_insertion_point(field_mutable:proto.MinesPlaceBetReq.roundId)
  return _s;
}
inline const std::string& MinesPlaceBetReq::_internal_roundid() const {
  return _impl_.roundid_.Get();
}
inline void MinesPlaceBetReq::_internal_set_roundid(const std::string& value) {
  
  _impl_.roundid_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesPlaceBetReq::_internal_mutable_roundid() {
  
  return _impl_.roundid_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesPlaceBetReq::release_roundid() {
  // @@protoc_insertion_point(field_release:proto.MinesPlaceBetReq.roundId)
  return _impl_.roundid_.Release();
}
inline void MinesPlaceBetReq::set_allocated_roundid(std::string* roundid) {
  if (roundid != nullptr) {
    
  } else {
    
  }
  _impl_.roundid_.SetAllocated(roundid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roundid_.IsDefault()) {
    _impl_.roundid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesPlaceBetReq.roundId)
}

// int32 playType = 3;
inline void MinesPlaceBetReq::clear_playtype() {
  _impl_.playtype_ = 0;
}
inline int32_t MinesPlaceBetReq::_internal_playtype() const {
  return _impl_.playtype_;
}
inline int32_t MinesPlaceBetReq::playtype() const {
  // @@protoc_insertion_point(field_get:proto.MinesPlaceBetReq.playType)
  return _internal_playtype();
}
inline void MinesPlaceBetReq::_internal_set_playtype(int32_t value) {
  
  _impl_.playtype_ = value;
}
inline void MinesPlaceBetReq::set_playtype(int32_t value) {
  _internal_set_playtype(value);
  // @@protoc_insertion_point(field_set:proto.MinesPlaceBetReq.playType)
}

// double amount = 4;
inline void MinesPlaceBetReq::clear_amount() {
  _impl_.amount_ = 0;
}
inline double MinesPlaceBetReq::_internal_amount() const {
  return _impl_.amount_;
}
inline double MinesPlaceBetReq::amount() const {
  // @@protoc_insertion_point(field_get:proto.MinesPlaceBetReq.amount)
  return _internal_amount();
}
inline void MinesPlaceBetReq::_internal_set_amount(double value) {
  
  _impl_.amount_ = value;
}
inline void MinesPlaceBetReq::set_amount(double value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:proto.MinesPlaceBetReq.amount)
}

// -------------------------------------------------------------------

// MinesPlaceBetRes

// int32 code = 1;
inline void MinesPlaceBetRes::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t MinesPlaceBetRes::_internal_code() const {
  return _impl_.code_;
}
inline int32_t MinesPlaceBetRes::code() const {
  // @@protoc_insertion_point(field_get:proto.MinesPlaceBetRes.code)
  return _internal_code();
}
inline void MinesPlaceBetRes::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void MinesPlaceBetRes::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:proto.MinesPlaceBetRes.code)
}

// string message = 2;
inline void MinesPlaceBetRes::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& MinesPlaceBetRes::message() const {
  // @@protoc_insertion_point(field_get:proto.MinesPlaceBetRes.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesPlaceBetRes::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesPlaceBetRes.message)
}
inline std::string* MinesPlaceBetRes::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:proto.MinesPlaceBetRes.message)
  return _s;
}
inline const std::string& MinesPlaceBetRes::_internal_message() const {
  return _impl_.message_.Get();
}
inline void MinesPlaceBetRes::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesPlaceBetRes::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesPlaceBetRes::release_message() {
  // @@protoc_insertion_point(field_release:proto.MinesPlaceBetRes.message)
  return _impl_.message_.Release();
}
inline void MinesPlaceBetRes::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesPlaceBetRes.message)
}

// string roundId = 3;
inline void MinesPlaceBetRes::clear_roundid() {
  _impl_.roundid_.ClearToEmpty();
}
inline const std::string& MinesPlaceBetRes::roundid() const {
  // @@protoc_insertion_point(field_get:proto.MinesPlaceBetRes.roundId)
  return _internal_roundid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesPlaceBetRes::set_roundid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roundid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesPlaceBetRes.roundId)
}
inline std::string* MinesPlaceBetRes::mutable_roundid() {
  std::string* _s = _internal_mutable_roundid();
  // @@protoc_insertion_point(field_mutable:proto.MinesPlaceBetRes.roundId)
  return _s;
}
inline const std::string& MinesPlaceBetRes::_internal_roundid() const {
  return _impl_.roundid_.Get();
}
inline void MinesPlaceBetRes::_internal_set_roundid(const std::string& value) {
  
  _impl_.roundid_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesPlaceBetRes::_internal_mutable_roundid() {
  
  return _impl_.roundid_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesPlaceBetRes::release_roundid() {
  // @@protoc_insertion_point(field_release:proto.MinesPlaceBetRes.roundId)
  return _impl_.roundid_.Release();
}
inline void MinesPlaceBetRes::set_allocated_roundid(std::string* roundid) {
  if (roundid != nullptr) {
    
  } else {
    
  }
  _impl_.roundid_.SetAllocated(roundid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roundid_.IsDefault()) {
    _impl_.roundid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesPlaceBetRes.roundId)
}

// .proto.BetRecord bet = 4;
inline bool MinesPlaceBetRes::_internal_has_bet() const {
  return this != internal_default_instance() && _impl_.bet_ != nullptr;
}
inline bool MinesPlaceBetRes::has_bet() const {
  return _internal_has_bet();
}
inline void MinesPlaceBetRes::clear_bet() {
  if (GetArenaForAllocation() == nullptr && _impl_.bet_ != nullptr) {
    delete _impl_.bet_;
  }
  _impl_.bet_ = nullptr;
}
inline const ::proto::BetRecord& MinesPlaceBetRes::_internal_bet() const {
  const ::proto::BetRecord* p = _impl_.bet_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::BetRecord&>(
      ::proto::_BetRecord_default_instance_);
}
inline const ::proto::BetRecord& MinesPlaceBetRes::bet() const {
  // @@protoc_insertion_point(field_get:proto.MinesPlaceBetRes.bet)
  return _internal_bet();
}
inline void MinesPlaceBetRes::unsafe_arena_set_allocated_bet(
    ::proto::BetRecord* bet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bet_);
  }
  _impl_.bet_ = bet;
  if (bet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.MinesPlaceBetRes.bet)
}
inline ::proto::BetRecord* MinesPlaceBetRes::release_bet() {
  
  ::proto::BetRecord* temp = _impl_.bet_;
  _impl_.bet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::BetRecord* MinesPlaceBetRes::unsafe_arena_release_bet() {
  // @@protoc_insertion_point(field_release:proto.MinesPlaceBetRes.bet)
  
  ::proto::BetRecord* temp = _impl_.bet_;
  _impl_.bet_ = nullptr;
  return temp;
}
inline ::proto::BetRecord* MinesPlaceBetRes::_internal_mutable_bet() {
  
  if (_impl_.bet_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::BetRecord>(GetArenaForAllocation());
    _impl_.bet_ = p;
  }
  return _impl_.bet_;
}
inline ::proto::BetRecord* MinesPlaceBetRes::mutable_bet() {
  ::proto::BetRecord* _msg = _internal_mutable_bet();
  // @@protoc_insertion_point(field_mutable:proto.MinesPlaceBetRes.bet)
  return _msg;
}
inline void MinesPlaceBetRes::set_allocated_bet(::proto::BetRecord* bet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bet_;
  }
  if (bet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bet);
    if (message_arena != submessage_arena) {
      bet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bet, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bet_ = bet;
  // @@protoc_insertion_point(field_set_allocated:proto.MinesPlaceBetRes.bet)
}

// double balance = 5;
inline void MinesPlaceBetRes::clear_balance() {
  _impl_.balance_ = 0;
}
inline double MinesPlaceBetRes::_internal_balance() const {
  return _impl_.balance_;
}
inline double MinesPlaceBetRes::balance() const {
  // @@protoc_insertion_point(field_get:proto.MinesPlaceBetRes.balance)
  return _internal_balance();
}
inline void MinesPlaceBetRes::_internal_set_balance(double value) {
  
  _impl_.balance_ = value;
}
inline void MinesPlaceBetRes::set_balance(double value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:proto.MinesPlaceBetRes.balance)
}

// -------------------------------------------------------------------

// MinesAutoCashReq

// string loginname = 1;
inline void MinesAutoCashReq::clear_loginname() {
  _impl_.loginname_.ClearToEmpty();
}
inline const std::string& MinesAutoCashReq::loginname() const {
  // @@protoc_insertion_point(field_get:proto.MinesAutoCashReq.loginname)
  return _internal_loginname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesAutoCashReq::set_loginname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loginname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesAutoCashReq.loginname)
}
inline std::string* MinesAutoCashReq::mutable_loginname() {
  std::string* _s = _internal_mutable_loginname();
  // @@protoc_insertion_point(field_mutable:proto.MinesAutoCashReq.loginname)
  return _s;
}
inline const std::string& MinesAutoCashReq::_internal_loginname() const {
  return _impl_.loginname_.Get();
}
inline void MinesAutoCashReq::_internal_set_loginname(const std::string& value) {
  
  _impl_.loginname_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesAutoCashReq::_internal_mutable_loginname() {
  
  return _impl_.loginname_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesAutoCashReq::release_loginname() {
  // @@protoc_insertion_point(field_release:proto.MinesAutoCashReq.loginname)
  return _impl_.loginname_.Release();
}
inline void MinesAutoCashReq::set_allocated_loginname(std::string* loginname) {
  if (loginname != nullptr) {
    
  } else {
    
  }
  _impl_.loginname_.SetAllocated(loginname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loginname_.IsDefault()) {
    _impl_.loginname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesAutoCashReq.loginname)
}

// string roundId = 2;
inline void MinesAutoCashReq::clear_roundid() {
  _impl_.roundid_.ClearToEmpty();
}
inline const std::string& MinesAutoCashReq::roundid() const {
  // @@protoc_insertion_point(field_get:proto.MinesAutoCashReq.roundId)
  return _internal_roundid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesAutoCashReq::set_roundid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roundid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesAutoCashReq.roundId)
}
inline std::string* MinesAutoCashReq::mutable_roundid() {
  std::string* _s = _internal_mutable_roundid();
  // @@protoc_insertion_point(field_mutable:proto.MinesAutoCashReq.roundId)
  return _s;
}
inline const std::string& MinesAutoCashReq::_internal_roundid() const {
  return _impl_.roundid_.Get();
}
inline void MinesAutoCashReq::_internal_set_roundid(const std::string& value) {
  
  _impl_.roundid_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesAutoCashReq::_internal_mutable_roundid() {
  
  return _impl_.roundid_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesAutoCashReq::release_roundid() {
  // @@protoc_insertion_point(field_release:proto.MinesAutoCashReq.roundId)
  return _impl_.roundid_.Release();
}
inline void MinesAutoCashReq::set_allocated_roundid(std::string* roundid) {
  if (roundid != nullptr) {
    
  } else {
    
  }
  _impl_.roundid_.SetAllocated(roundid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roundid_.IsDefault()) {
    _impl_.roundid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesAutoCashReq.roundId)
}

// int32 playType = 3;
inline void MinesAutoCashReq::clear_playtype() {
  _impl_.playtype_ = 0;
}
inline int32_t MinesAutoCashReq::_internal_playtype() const {
  return _impl_.playtype_;
}
inline int32_t MinesAutoCashReq::playtype() const {
  // @@protoc_insertion_point(field_get:proto.MinesAutoCashReq.playType)
  return _internal_playtype();
}
inline void MinesAutoCashReq::_internal_set_playtype(int32_t value) {
  
  _impl_.playtype_ = value;
}
inline void MinesAutoCashReq::set_playtype(int32_t value) {
  _internal_set_playtype(value);
  // @@protoc_insertion_point(field_set:proto.MinesAutoCashReq.playType)
}

// int32 enable = 4;
inline void MinesAutoCashReq::clear_enable() {
  _impl_.enable_ = 0;
}
inline int32_t MinesAutoCashReq::_internal_enable() const {
  return _impl_.enable_;
}
inline int32_t MinesAutoCashReq::enable() const {
  // @@protoc_insertion_point(field_get:proto.MinesAutoCashReq.enable)
  return _internal_enable();
}
inline void MinesAutoCashReq::_internal_set_enable(int32_t value) {
  
  _impl_.enable_ = value;
}
inline void MinesAutoCashReq::set_enable(int32_t value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:proto.MinesAutoCashReq.enable)
}

// int32 grid = 5;
inline void MinesAutoCashReq::clear_grid() {
  _impl_.grid_ = 0;
}
inline int32_t MinesAutoCashReq::_internal_grid() const {
  return _impl_.grid_;
}
inline int32_t MinesAutoCashReq::grid() const {
  // @@protoc_insertion_point(field_get:proto.MinesAutoCashReq.grid)
  return _internal_grid();
}
inline void MinesAutoCashReq::_internal_set_grid(int32_t value) {
  
  _impl_.grid_ = value;
}
inline void MinesAutoCashReq::set_grid(int32_t value) {
  _internal_set_grid(value);
  // @@protoc_insertion_point(field_set:proto.MinesAutoCashReq.grid)
}

// -------------------------------------------------------------------

// MinesAutoCashRes

// string roundId = 1;
inline void MinesAutoCashRes::clear_roundid() {
  _impl_.roundid_.ClearToEmpty();
}
inline const std::string& MinesAutoCashRes::roundid() const {
  // @@protoc_insertion_point(field_get:proto.MinesAutoCashRes.roundId)
  return _internal_roundid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesAutoCashRes::set_roundid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roundid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesAutoCashRes.roundId)
}
inline std::string* MinesAutoCashRes::mutable_roundid() {
  std::string* _s = _internal_mutable_roundid();
  // @@protoc_insertion_point(field_mutable:proto.MinesAutoCashRes.roundId)
  return _s;
}
inline const std::string& MinesAutoCashRes::_internal_roundid() const {
  return _impl_.roundid_.Get();
}
inline void MinesAutoCashRes::_internal_set_roundid(const std::string& value) {
  
  _impl_.roundid_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesAutoCashRes::_internal_mutable_roundid() {
  
  return _impl_.roundid_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesAutoCashRes::release_roundid() {
  // @@protoc_insertion_point(field_release:proto.MinesAutoCashRes.roundId)
  return _impl_.roundid_.Release();
}
inline void MinesAutoCashRes::set_allocated_roundid(std::string* roundid) {
  if (roundid != nullptr) {
    
  } else {
    
  }
  _impl_.roundid_.SetAllocated(roundid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roundid_.IsDefault()) {
    _impl_.roundid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesAutoCashRes.roundId)
}

// int32 code = 2;
inline void MinesAutoCashRes::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t MinesAutoCashRes::_internal_code() const {
  return _impl_.code_;
}
inline int32_t MinesAutoCashRes::code() const {
  // @@protoc_insertion_point(field_get:proto.MinesAutoCashRes.code)
  return _internal_code();
}
inline void MinesAutoCashRes::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void MinesAutoCashRes::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:proto.MinesAutoCashRes.code)
}

// string message = 3;
inline void MinesAutoCashRes::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& MinesAutoCashRes::message() const {
  // @@protoc_insertion_point(field_get:proto.MinesAutoCashRes.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesAutoCashRes::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesAutoCashRes.message)
}
inline std::string* MinesAutoCashRes::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:proto.MinesAutoCashRes.message)
  return _s;
}
inline const std::string& MinesAutoCashRes::_internal_message() const {
  return _impl_.message_.Get();
}
inline void MinesAutoCashRes::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesAutoCashRes::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesAutoCashRes::release_message() {
  // @@protoc_insertion_point(field_release:proto.MinesAutoCashRes.message)
  return _impl_.message_.Release();
}
inline void MinesAutoCashRes::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesAutoCashRes.message)
}

// int32 enable = 4;
inline void MinesAutoCashRes::clear_enable() {
  _impl_.enable_ = 0;
}
inline int32_t MinesAutoCashRes::_internal_enable() const {
  return _impl_.enable_;
}
inline int32_t MinesAutoCashRes::enable() const {
  // @@protoc_insertion_point(field_get:proto.MinesAutoCashRes.enable)
  return _internal_enable();
}
inline void MinesAutoCashRes::_internal_set_enable(int32_t value) {
  
  _impl_.enable_ = value;
}
inline void MinesAutoCashRes::set_enable(int32_t value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:proto.MinesAutoCashRes.enable)
}

// int32 grid = 5;
inline void MinesAutoCashRes::clear_grid() {
  _impl_.grid_ = 0;
}
inline int32_t MinesAutoCashRes::_internal_grid() const {
  return _impl_.grid_;
}
inline int32_t MinesAutoCashRes::grid() const {
  // @@protoc_insertion_point(field_get:proto.MinesAutoCashRes.grid)
  return _internal_grid();
}
inline void MinesAutoCashRes::_internal_set_grid(int32_t value) {
  
  _impl_.grid_ = value;
}
inline void MinesAutoCashRes::set_grid(int32_t value) {
  _internal_set_grid(value);
  // @@protoc_insertion_point(field_set:proto.MinesAutoCashRes.grid)
}

// int32 playType = 6;
inline void MinesAutoCashRes::clear_playtype() {
  _impl_.playtype_ = 0;
}
inline int32_t MinesAutoCashRes::_internal_playtype() const {
  return _impl_.playtype_;
}
inline int32_t MinesAutoCashRes::playtype() const {
  // @@protoc_insertion_point(field_get:proto.MinesAutoCashRes.playType)
  return _internal_playtype();
}
inline void MinesAutoCashRes::_internal_set_playtype(int32_t value) {
  
  _impl_.playtype_ = value;
}
inline void MinesAutoCashRes::set_playtype(int32_t value) {
  _internal_set_playtype(value);
  // @@protoc_insertion_point(field_set:proto.MinesAutoCashRes.playType)
}

// -------------------------------------------------------------------

// MinesCashReq

// string loginname = 1;
inline void MinesCashReq::clear_loginname() {
  _impl_.loginname_.ClearToEmpty();
}
inline const std::string& MinesCashReq::loginname() const {
  // @@protoc_insertion_point(field_get:proto.MinesCashReq.loginname)
  return _internal_loginname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesCashReq::set_loginname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loginname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesCashReq.loginname)
}
inline std::string* MinesCashReq::mutable_loginname() {
  std::string* _s = _internal_mutable_loginname();
  // @@protoc_insertion_point(field_mutable:proto.MinesCashReq.loginname)
  return _s;
}
inline const std::string& MinesCashReq::_internal_loginname() const {
  return _impl_.loginname_.Get();
}
inline void MinesCashReq::_internal_set_loginname(const std::string& value) {
  
  _impl_.loginname_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesCashReq::_internal_mutable_loginname() {
  
  return _impl_.loginname_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesCashReq::release_loginname() {
  // @@protoc_insertion_point(field_release:proto.MinesCashReq.loginname)
  return _impl_.loginname_.Release();
}
inline void MinesCashReq::set_allocated_loginname(std::string* loginname) {
  if (loginname != nullptr) {
    
  } else {
    
  }
  _impl_.loginname_.SetAllocated(loginname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loginname_.IsDefault()) {
    _impl_.loginname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesCashReq.loginname)
}

// string roundId = 2;
inline void MinesCashReq::clear_roundid() {
  _impl_.roundid_.ClearToEmpty();
}
inline const std::string& MinesCashReq::roundid() const {
  // @@protoc_insertion_point(field_get:proto.MinesCashReq.roundId)
  return _internal_roundid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesCashReq::set_roundid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roundid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesCashReq.roundId)
}
inline std::string* MinesCashReq::mutable_roundid() {
  std::string* _s = _internal_mutable_roundid();
  // @@protoc_insertion_point(field_mutable:proto.MinesCashReq.roundId)
  return _s;
}
inline const std::string& MinesCashReq::_internal_roundid() const {
  return _impl_.roundid_.Get();
}
inline void MinesCashReq::_internal_set_roundid(const std::string& value) {
  
  _impl_.roundid_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesCashReq::_internal_mutable_roundid() {
  
  return _impl_.roundid_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesCashReq::release_roundid() {
  // @@protoc_insertion_point(field_release:proto.MinesCashReq.roundId)
  return _impl_.roundid_.Release();
}
inline void MinesCashReq::set_allocated_roundid(std::string* roundid) {
  if (roundid != nullptr) {
    
  } else {
    
  }
  _impl_.roundid_.SetAllocated(roundid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roundid_.IsDefault()) {
    _impl_.roundid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesCashReq.roundId)
}

// int32 playType = 3;
inline void MinesCashReq::clear_playtype() {
  _impl_.playtype_ = 0;
}
inline int32_t MinesCashReq::_internal_playtype() const {
  return _impl_.playtype_;
}
inline int32_t MinesCashReq::playtype() const {
  // @@protoc_insertion_point(field_get:proto.MinesCashReq.playType)
  return _internal_playtype();
}
inline void MinesCashReq::_internal_set_playtype(int32_t value) {
  
  _impl_.playtype_ = value;
}
inline void MinesCashReq::set_playtype(int32_t value) {
  _internal_set_playtype(value);
  // @@protoc_insertion_point(field_set:proto.MinesCashReq.playType)
}

// -------------------------------------------------------------------

// MinesCashRes

// string roundId = 1;
inline void MinesCashRes::clear_roundid() {
  _impl_.roundid_.ClearToEmpty();
}
inline const std::string& MinesCashRes::roundid() const {
  // @@protoc_insertion_point(field_get:proto.MinesCashRes.roundId)
  return _internal_roundid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesCashRes::set_roundid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roundid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesCashRes.roundId)
}
inline std::string* MinesCashRes::mutable_roundid() {
  std::string* _s = _internal_mutable_roundid();
  // @@protoc_insertion_point(field_mutable:proto.MinesCashRes.roundId)
  return _s;
}
inline const std::string& MinesCashRes::_internal_roundid() const {
  return _impl_.roundid_.Get();
}
inline void MinesCashRes::_internal_set_roundid(const std::string& value) {
  
  _impl_.roundid_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesCashRes::_internal_mutable_roundid() {
  
  return _impl_.roundid_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesCashRes::release_roundid() {
  // @@protoc_insertion_point(field_release:proto.MinesCashRes.roundId)
  return _impl_.roundid_.Release();
}
inline void MinesCashRes::set_allocated_roundid(std::string* roundid) {
  if (roundid != nullptr) {
    
  } else {
    
  }
  _impl_.roundid_.SetAllocated(roundid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roundid_.IsDefault()) {
    _impl_.roundid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesCashRes.roundId)
}

// int32 code = 2;
inline void MinesCashRes::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t MinesCashRes::_internal_code() const {
  return _impl_.code_;
}
inline int32_t MinesCashRes::code() const {
  // @@protoc_insertion_point(field_get:proto.MinesCashRes.code)
  return _internal_code();
}
inline void MinesCashRes::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void MinesCashRes::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:proto.MinesCashRes.code)
}

// string message = 3;
inline void MinesCashRes::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& MinesCashRes::message() const {
  // @@protoc_insertion_point(field_get:proto.MinesCashRes.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesCashRes::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesCashRes.message)
}
inline std::string* MinesCashRes::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:proto.MinesCashRes.message)
  return _s;
}
inline const std::string& MinesCashRes::_internal_message() const {
  return _impl_.message_.Get();
}
inline void MinesCashRes::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesCashRes::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesCashRes::release_message() {
  // @@protoc_insertion_point(field_release:proto.MinesCashRes.message)
  return _impl_.message_.Release();
}
inline void MinesCashRes::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesCashRes.message)
}

// .proto.ReckonRecord reckon = 4;
inline bool MinesCashRes::_internal_has_reckon() const {
  return this != internal_default_instance() && _impl_.reckon_ != nullptr;
}
inline bool MinesCashRes::has_reckon() const {
  return _internal_has_reckon();
}
inline void MinesCashRes::clear_reckon() {
  if (GetArenaForAllocation() == nullptr && _impl_.reckon_ != nullptr) {
    delete _impl_.reckon_;
  }
  _impl_.reckon_ = nullptr;
}
inline const ::proto::ReckonRecord& MinesCashRes::_internal_reckon() const {
  const ::proto::ReckonRecord* p = _impl_.reckon_;
  return p != nullptr ? *p : reinterpret_cast<const ::proto::ReckonRecord&>(
      ::proto::_ReckonRecord_default_instance_);
}
inline const ::proto::ReckonRecord& MinesCashRes::reckon() const {
  // @@protoc_insertion_point(field_get:proto.MinesCashRes.reckon)
  return _internal_reckon();
}
inline void MinesCashRes::unsafe_arena_set_allocated_reckon(
    ::proto::ReckonRecord* reckon) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reckon_);
  }
  _impl_.reckon_ = reckon;
  if (reckon) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:proto.MinesCashRes.reckon)
}
inline ::proto::ReckonRecord* MinesCashRes::release_reckon() {
  
  ::proto::ReckonRecord* temp = _impl_.reckon_;
  _impl_.reckon_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::proto::ReckonRecord* MinesCashRes::unsafe_arena_release_reckon() {
  // @@protoc_insertion_point(field_release:proto.MinesCashRes.reckon)
  
  ::proto::ReckonRecord* temp = _impl_.reckon_;
  _impl_.reckon_ = nullptr;
  return temp;
}
inline ::proto::ReckonRecord* MinesCashRes::_internal_mutable_reckon() {
  
  if (_impl_.reckon_ == nullptr) {
    auto* p = CreateMaybeMessage<::proto::ReckonRecord>(GetArenaForAllocation());
    _impl_.reckon_ = p;
  }
  return _impl_.reckon_;
}
inline ::proto::ReckonRecord* MinesCashRes::mutable_reckon() {
  ::proto::ReckonRecord* _msg = _internal_mutable_reckon();
  // @@protoc_insertion_point(field_mutable:proto.MinesCashRes.reckon)
  return _msg;
}
inline void MinesCashRes::set_allocated_reckon(::proto::ReckonRecord* reckon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reckon_;
  }
  if (reckon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reckon);
    if (message_arena != submessage_arena) {
      reckon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reckon, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.reckon_ = reckon;
  // @@protoc_insertion_point(field_set_allocated:proto.MinesCashRes.reckon)
}

// double balance = 5;
inline void MinesCashRes::clear_balance() {
  _impl_.balance_ = 0;
}
inline double MinesCashRes::_internal_balance() const {
  return _impl_.balance_;
}
inline double MinesCashRes::balance() const {
  // @@protoc_insertion_point(field_get:proto.MinesCashRes.balance)
  return _internal_balance();
}
inline void MinesCashRes::_internal_set_balance(double value) {
  
  _impl_.balance_ = value;
}
inline void MinesCashRes::set_balance(double value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:proto.MinesCashRes.balance)
}

// int32 playType = 6;
inline void MinesCashRes::clear_playtype() {
  _impl_.playtype_ = 0;
}
inline int32_t MinesCashRes::_internal_playtype() const {
  return _impl_.playtype_;
}
inline int32_t MinesCashRes::playtype() const {
  // @@protoc_insertion_point(field_get:proto.MinesCashRes.playType)
  return _internal_playtype();
}
inline void MinesCashRes::_internal_set_playtype(int32_t value) {
  
  _impl_.playtype_ = value;
}
inline void MinesCashRes::set_playtype(int32_t value) {
  _internal_set_playtype(value);
  // @@protoc_insertion_point(field_set:proto.MinesCashRes.playType)
}

// -------------------------------------------------------------------

// MinesCancelBetReq

// string loginname = 1;
inline void MinesCancelBetReq::clear_loginname() {
  _impl_.loginname_.ClearToEmpty();
}
inline const std::string& MinesCancelBetReq::loginname() const {
  // @@protoc_insertion_point(field_get:proto.MinesCancelBetReq.loginname)
  return _internal_loginname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesCancelBetReq::set_loginname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.loginname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesCancelBetReq.loginname)
}
inline std::string* MinesCancelBetReq::mutable_loginname() {
  std::string* _s = _internal_mutable_loginname();
  // @@protoc_insertion_point(field_mutable:proto.MinesCancelBetReq.loginname)
  return _s;
}
inline const std::string& MinesCancelBetReq::_internal_loginname() const {
  return _impl_.loginname_.Get();
}
inline void MinesCancelBetReq::_internal_set_loginname(const std::string& value) {
  
  _impl_.loginname_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesCancelBetReq::_internal_mutable_loginname() {
  
  return _impl_.loginname_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesCancelBetReq::release_loginname() {
  // @@protoc_insertion_point(field_release:proto.MinesCancelBetReq.loginname)
  return _impl_.loginname_.Release();
}
inline void MinesCancelBetReq::set_allocated_loginname(std::string* loginname) {
  if (loginname != nullptr) {
    
  } else {
    
  }
  _impl_.loginname_.SetAllocated(loginname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.loginname_.IsDefault()) {
    _impl_.loginname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesCancelBetReq.loginname)
}

// string roundId = 2;
inline void MinesCancelBetReq::clear_roundid() {
  _impl_.roundid_.ClearToEmpty();
}
inline const std::string& MinesCancelBetReq::roundid() const {
  // @@protoc_insertion_point(field_get:proto.MinesCancelBetReq.roundId)
  return _internal_roundid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesCancelBetReq::set_roundid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roundid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesCancelBetReq.roundId)
}
inline std::string* MinesCancelBetReq::mutable_roundid() {
  std::string* _s = _internal_mutable_roundid();
  // @@protoc_insertion_point(field_mutable:proto.MinesCancelBetReq.roundId)
  return _s;
}
inline const std::string& MinesCancelBetReq::_internal_roundid() const {
  return _impl_.roundid_.Get();
}
inline void MinesCancelBetReq::_internal_set_roundid(const std::string& value) {
  
  _impl_.roundid_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesCancelBetReq::_internal_mutable_roundid() {
  
  return _impl_.roundid_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesCancelBetReq::release_roundid() {
  // @@protoc_insertion_point(field_release:proto.MinesCancelBetReq.roundId)
  return _impl_.roundid_.Release();
}
inline void MinesCancelBetReq::set_allocated_roundid(std::string* roundid) {
  if (roundid != nullptr) {
    
  } else {
    
  }
  _impl_.roundid_.SetAllocated(roundid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roundid_.IsDefault()) {
    _impl_.roundid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesCancelBetReq.roundId)
}

// int32 playType = 3;
inline void MinesCancelBetReq::clear_playtype() {
  _impl_.playtype_ = 0;
}
inline int32_t MinesCancelBetReq::_internal_playtype() const {
  return _impl_.playtype_;
}
inline int32_t MinesCancelBetReq::playtype() const {
  // @@protoc_insertion_point(field_get:proto.MinesCancelBetReq.playType)
  return _internal_playtype();
}
inline void MinesCancelBetReq::_internal_set_playtype(int32_t value) {
  
  _impl_.playtype_ = value;
}
inline void MinesCancelBetReq::set_playtype(int32_t value) {
  _internal_set_playtype(value);
  // @@protoc_insertion_point(field_set:proto.MinesCancelBetReq.playType)
}

// -------------------------------------------------------------------

// MinesCancelBetRes

// string roundId = 1;
inline void MinesCancelBetRes::clear_roundid() {
  _impl_.roundid_.ClearToEmpty();
}
inline const std::string& MinesCancelBetRes::roundid() const {
  // @@protoc_insertion_point(field_get:proto.MinesCancelBetRes.roundId)
  return _internal_roundid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesCancelBetRes::set_roundid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roundid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesCancelBetRes.roundId)
}
inline std::string* MinesCancelBetRes::mutable_roundid() {
  std::string* _s = _internal_mutable_roundid();
  // @@protoc_insertion_point(field_mutable:proto.MinesCancelBetRes.roundId)
  return _s;
}
inline const std::string& MinesCancelBetRes::_internal_roundid() const {
  return _impl_.roundid_.Get();
}
inline void MinesCancelBetRes::_internal_set_roundid(const std::string& value) {
  
  _impl_.roundid_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesCancelBetRes::_internal_mutable_roundid() {
  
  return _impl_.roundid_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesCancelBetRes::release_roundid() {
  // @@protoc_insertion_point(field_release:proto.MinesCancelBetRes.roundId)
  return _impl_.roundid_.Release();
}
inline void MinesCancelBetRes::set_allocated_roundid(std::string* roundid) {
  if (roundid != nullptr) {
    
  } else {
    
  }
  _impl_.roundid_.SetAllocated(roundid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roundid_.IsDefault()) {
    _impl_.roundid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesCancelBetRes.roundId)
}

// int32 code = 2;
inline void MinesCancelBetRes::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t MinesCancelBetRes::_internal_code() const {
  return _impl_.code_;
}
inline int32_t MinesCancelBetRes::code() const {
  // @@protoc_insertion_point(field_get:proto.MinesCancelBetRes.code)
  return _internal_code();
}
inline void MinesCancelBetRes::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void MinesCancelBetRes::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:proto.MinesCancelBetRes.code)
}

// string message = 3;
inline void MinesCancelBetRes::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& MinesCancelBetRes::message() const {
  // @@protoc_insertion_point(field_get:proto.MinesCancelBetRes.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesCancelBetRes::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesCancelBetRes.message)
}
inline std::string* MinesCancelBetRes::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:proto.MinesCancelBetRes.message)
  return _s;
}
inline const std::string& MinesCancelBetRes::_internal_message() const {
  return _impl_.message_.Get();
}
inline void MinesCancelBetRes::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesCancelBetRes::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesCancelBetRes::release_message() {
  // @@protoc_insertion_point(field_release:proto.MinesCancelBetRes.message)
  return _impl_.message_.Release();
}
inline void MinesCancelBetRes::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesCancelBetRes.message)
}

// double refundAmount = 4;
inline void MinesCancelBetRes::clear_refundamount() {
  _impl_.refundamount_ = 0;
}
inline double MinesCancelBetRes::_internal_refundamount() const {
  return _impl_.refundamount_;
}
inline double MinesCancelBetRes::refundamount() const {
  // @@protoc_insertion_point(field_get:proto.MinesCancelBetRes.refundAmount)
  return _internal_refundamount();
}
inline void MinesCancelBetRes::_internal_set_refundamount(double value) {
  
  _impl_.refundamount_ = value;
}
inline void MinesCancelBetRes::set_refundamount(double value) {
  _internal_set_refundamount(value);
  // @@protoc_insertion_point(field_set:proto.MinesCancelBetRes.refundAmount)
}

// double balance = 5;
inline void MinesCancelBetRes::clear_balance() {
  _impl_.balance_ = 0;
}
inline double MinesCancelBetRes::_internal_balance() const {
  return _impl_.balance_;
}
inline double MinesCancelBetRes::balance() const {
  // @@protoc_insertion_point(field_get:proto.MinesCancelBetRes.balance)
  return _internal_balance();
}
inline void MinesCancelBetRes::_internal_set_balance(double value) {
  
  _impl_.balance_ = value;
}
inline void MinesCancelBetRes::set_balance(double value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:proto.MinesCancelBetRes.balance)
}

// int32 playType = 6;
inline void MinesCancelBetRes::clear_playtype() {
  _impl_.playtype_ = 0;
}
inline int32_t MinesCancelBetRes::_internal_playtype() const {
  return _impl_.playtype_;
}
inline int32_t MinesCancelBetRes::playtype() const {
  // @@protoc_insertion_point(field_get:proto.MinesCancelBetRes.playType)
  return _internal_playtype();
}
inline void MinesCancelBetRes::_internal_set_playtype(int32_t value) {
  
  _impl_.playtype_ = value;
}
inline void MinesCancelBetRes::set_playtype(int32_t value) {
  _internal_set_playtype(value);
  // @@protoc_insertion_point(field_set:proto.MinesCancelBetRes.playType)
}

// -------------------------------------------------------------------

// MinesStartJettonNotify

// string roundId = 1;
inline void MinesStartJettonNotify::clear_roundid() {
  _impl_.roundid_.ClearToEmpty();
}
inline const std::string& MinesStartJettonNotify::roundid() const {
  // @@protoc_insertion_point(field_get:proto.MinesStartJettonNotify.roundId)
  return _internal_roundid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesStartJettonNotify::set_roundid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roundid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesStartJettonNotify.roundId)
}
inline std::string* MinesStartJettonNotify::mutable_roundid() {
  std::string* _s = _internal_mutable_roundid();
  // @@protoc_insertion_point(field_mutable:proto.MinesStartJettonNotify.roundId)
  return _s;
}
inline const std::string& MinesStartJettonNotify::_internal_roundid() const {
  return _impl_.roundid_.Get();
}
inline void MinesStartJettonNotify::_internal_set_roundid(const std::string& value) {
  
  _impl_.roundid_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesStartJettonNotify::_internal_mutable_roundid() {
  
  return _impl_.roundid_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesStartJettonNotify::release_roundid() {
  // @@protoc_insertion_point(field_release:proto.MinesStartJettonNotify.roundId)
  return _impl_.roundid_.Release();
}
inline void MinesStartJettonNotify::set_allocated_roundid(std::string* roundid) {
  if (roundid != nullptr) {
    
  } else {
    
  }
  _impl_.roundid_.SetAllocated(roundid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roundid_.IsDefault()) {
    _impl_.roundid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesStartJettonNotify.roundId)
}

// string gametype = 2;
inline void MinesStartJettonNotify::clear_gametype() {
  _impl_.gametype_.ClearToEmpty();
}
inline const std::string& MinesStartJettonNotify::gametype() const {
  // @@protoc_insertion_point(field_get:proto.MinesStartJettonNotify.gametype)
  return _internal_gametype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MinesStartJettonNotify::set_gametype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gametype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.MinesStartJettonNotify.gametype)
}
inline std::string* MinesStartJettonNotify::mutable_gametype() {
  std::string* _s = _internal_mutable_gametype();
  // @@protoc_insertion_point(field_mutable:proto.MinesStartJettonNotify.gametype)
  return _s;
}
inline const std::string& MinesStartJettonNotify::_internal_gametype() const {
  return _impl_.gametype_.Get();
}
inline void MinesStartJettonNotify::_internal_set_gametype(const std::string& value) {
  
  _impl_.gametype_.Set(value, GetArenaForAllocation());
}
inline std::string* MinesStartJettonNotify::_internal_mutable_gametype() {
  
  return _impl_.gametype_.Mutable(GetArenaForAllocation());
}
inline std::string* MinesStartJettonNotify::release_gametype() {
  // @@protoc_insertion_point(field_release:proto.MinesStartJettonNotify.gametype)
  return _impl_.gametype_.Release();
}
inline void MinesStartJettonNotify::set_allocated_gametype(std::string* gametype) {
  if (gametype != nullptr) {
    
  } else {
    
  }
  _impl_.gametype_.SetAllocated(gametype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gametype_.IsDefault()) {
    _impl_.gametype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.MinesStartJettonNotify.gametype)
}

// int64 duration = 3;
inline void MinesStartJettonNotify::clear_duration() {
  _impl_.duration_ = int64_t{0};
}
inline int64_t MinesStartJettonNotify::_internal_duration() const {
  return _impl_.duration_;
}
inline int64_t MinesStartJettonNotify::duration() const {
  // @@protoc_insertion_point(field_get:proto.MinesStartJettonNotify.duration)
  return _internal_duration();
}
inline void MinesStartJettonNotify::_internal_set_duration(int64_t value) {
  
  _impl_.duration_ = value;
}
inline void MinesStartJettonNotify::set_duration(int64_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:proto.MinesStartJettonNotify.duration)
}

// -------------------------------------------------------------------

// GameStopJettonNotify

// string roundId = 1;
inline void GameStopJettonNotify::clear_roundid() {
  _impl_.roundid_.ClearToEmpty();
}
inline const std::string& GameStopJettonNotify::roundid() const {
  // @@protoc_insertion_point(field_get:proto.GameStopJettonNotify.roundId)
  return _internal_roundid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameStopJettonNotify::set_roundid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roundid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.GameStopJettonNotify.roundId)
}
inline std::string* GameStopJettonNotify::mutable_roundid() {
  std::string* _s = _internal_mutable_roundid();
  // @@protoc_insertion_point(field_mutable:proto.GameStopJettonNotify.roundId)
  return _s;
}
inline const std::string& GameStopJettonNotify::_internal_roundid() const {
  return _impl_.roundid_.Get();
}
inline void GameStopJettonNotify::_internal_set_roundid(const std::string& value) {
  
  _impl_.roundid_.Set(value, GetArenaForAllocation());
}
inline std::string* GameStopJettonNotify::_internal_mutable_roundid() {
  
  return _impl_.roundid_.Mutable(GetArenaForAllocation());
}
inline std::string* GameStopJettonNotify::release_roundid() {
  // @@protoc_insertion_point(field_release:proto.GameStopJettonNotify.roundId)
  return _impl_.roundid_.Release();
}
inline void GameStopJettonNotify::set_allocated_roundid(std::string* roundid) {
  if (roundid != nullptr) {
    
  } else {
    
  }
  _impl_.roundid_.SetAllocated(roundid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roundid_.IsDefault()) {
    _impl_.roundid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.GameStopJettonNotify.roundId)
}

// string gameType = 2;
inline void GameStopJettonNotify::clear_gametype() {
  _impl_.gametype_.ClearToEmpty();
}
inline const std::string& GameStopJettonNotify::gametype() const {
  // @@protoc_insertion_point(field_get:proto.GameStopJettonNotify.gameType)
  return _internal_gametype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameStopJettonNotify::set_gametype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gametype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.GameStopJettonNotify.gameType)
}
inline std::string* GameStopJettonNotify::mutable_gametype() {
  std::string* _s = _internal_mutable_gametype();
  // @@protoc_insertion_point(field_mutable:proto.GameStopJettonNotify.gameType)
  return _s;
}
inline const std::string& GameStopJettonNotify::_internal_gametype() const {
  return _impl_.gametype_.Get();
}
inline void GameStopJettonNotify::_internal_set_gametype(const std::string& value) {
  
  _impl_.gametype_.Set(value, GetArenaForAllocation());
}
inline std::string* GameStopJettonNotify::_internal_mutable_gametype() {
  
  return _impl_.gametype_.Mutable(GetArenaForAllocation());
}
inline std::string* GameStopJettonNotify::release_gametype() {
  // @@protoc_insertion_point(field_release:proto.GameStopJettonNotify.gameType)
  return _impl_.gametype_.Release();
}
inline void GameStopJettonNotify::set_allocated_gametype(std::string* gametype) {
  if (gametype != nullptr) {
    
  } else {
    
  }
  _impl_.gametype_.SetAllocated(gametype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gametype_.IsDefault()) {
    _impl_.gametype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.GameStopJettonNotify.gameType)
}

// int64 stopTime = 3;
inline void GameStopJettonNotify::clear_stoptime() {
  _impl_.stoptime_ = int64_t{0};
}
inline int64_t GameStopJettonNotify::_internal_stoptime() const {
  return _impl_.stoptime_;
}
inline int64_t GameStopJettonNotify::stoptime() const {
  // @@protoc_insertion_point(field_get:proto.GameStopJettonNotify.stopTime)
  return _internal_stoptime();
}
inline void GameStopJettonNotify::_internal_set_stoptime(int64_t value) {
  
  _impl_.stoptime_ = value;
}
inline void GameStopJettonNotify::set_stoptime(int64_t value) {
  _internal_set_stoptime(value);
  // @@protoc_insertion_point(field_set:proto.GameStopJettonNotify.stopTime)
}

// -------------------------------------------------------------------

// GameRankInfoNotify

// string roundId = 1;
inline void GameRankInfoNotify::clear_roundid() {
  _impl_.roundid_.ClearToEmpty();
}
inline const std::string& GameRankInfoNotify::roundid() const {
  // @@protoc_insertion_point(field_get:proto.GameRankInfoNotify.roundId)
  return _internal_roundid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameRankInfoNotify::set_roundid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roundid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.GameRankInfoNotify.roundId)
}
inline std::string* GameRankInfoNotify::mutable_roundid() {
  std::string* _s = _internal_mutable_roundid();
  // @@protoc_insertion_point(field_mutable:proto.GameRankInfoNotify.roundId)
  return _s;
}
inline const std::string& GameRankInfoNotify::_internal_roundid() const {
  return _impl_.roundid_.Get();
}
inline void GameRankInfoNotify::_internal_set_roundid(const std::string& value) {
  
  _impl_.roundid_.Set(value, GetArenaForAllocation());
}
inline std::string* GameRankInfoNotify::_internal_mutable_roundid() {
  
  return _impl_.roundid_.Mutable(GetArenaForAllocation());
}
inline std::string* GameRankInfoNotify::release_roundid() {
  // @@protoc_insertion_point(field_release:proto.GameRankInfoNotify.roundId)
  return _impl_.roundid_.Release();
}
inline void GameRankInfoNotify::set_allocated_roundid(std::string* roundid) {
  if (roundid != nullptr) {
    
  } else {
    
  }
  _impl_.roundid_.SetAllocated(roundid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roundid_.IsDefault()) {
    _impl_.roundid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.GameRankInfoNotify.roundId)
}

// string gameType = 2;
inline void GameRankInfoNotify::clear_gametype() {
  _impl_.gametype_.ClearToEmpty();
}
inline const std::string& GameRankInfoNotify::gametype() const {
  // @@protoc_insertion_point(field_get:proto.GameRankInfoNotify.gameType)
  return _internal_gametype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameRankInfoNotify::set_gametype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gametype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:proto.GameRankInfoNotify.gameType)
}
inline std::string* GameRankInfoNotify::mutable_gametype() {
  std::string* _s = _internal_mutable_gametype();
  // @@protoc_insertion_point(field_mutable:proto.GameRankInfoNotify.gameType)
  return _s;
}
inline const std::string& GameRankInfoNotify::_internal_gametype() const {
  return _impl_.gametype_.Get();
}
inline void GameRankInfoNotify::_internal_set_gametype(const std::string& value) {
  
  _impl_.gametype_.Set(value, GetArenaForAllocation());
}
inline std::string* GameRankInfoNotify::_internal_mutable_gametype() {
  
  return _impl_.gametype_.Mutable(GetArenaForAllocation());
}
inline std::string* GameRankInfoNotify::release_gametype() {
  // @@protoc_insertion_point(field_release:proto.GameRankInfoNotify.gameType)
  return _impl_.gametype_.Release();
}
inline void GameRankInfoNotify::set_allocated_gametype(std::string* gametype) {
  if (gametype != nullptr) {
    
  } else {
    
  }
  _impl_.gametype_.SetAllocated(gametype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gametype_.IsDefault()) {
    _impl_.gametype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:proto.GameRankInfoNotify.gameType)
}

// repeated .proto.PlayerInfoSnap players = 3;
inline int GameRankInfoNotify::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int GameRankInfoNotify::players_size() const {
  return _internal_players_size();
}
inline void GameRankInfoNotify::clear_players() {
  _impl_.players_.Clear();
}
inline ::proto::PlayerInfoSnap* GameRankInfoNotify::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:proto.GameRankInfoNotify.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PlayerInfoSnap >*
GameRankInfoNotify::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:proto.GameRankInfoNotify.players)
  return &_impl_.players_;
}
inline const ::proto::PlayerInfoSnap& GameRankInfoNotify::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::proto::PlayerInfoSnap& GameRankInfoNotify::players(int index) const {
  // @@protoc_insertion_point(field_get:proto.GameRankInfoNotify.players)
  return _internal_players(index);
}
inline ::proto::PlayerInfoSnap* GameRankInfoNotify::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::proto::PlayerInfoSnap* GameRankInfoNotify::add_players() {
  ::proto::PlayerInfoSnap* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:proto.GameRankInfoNotify.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proto::PlayerInfoSnap >&
GameRankInfoNotify::players() const {
  // @@protoc_insertion_point(field_list:proto.GameRankInfoNotify.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// ConnClose

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_game_2eproto
